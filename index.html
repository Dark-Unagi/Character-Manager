<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG Character Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        'primary-dark': '#4845B8'
                    }
                }
            }
        }
    </script>
    <style>
        .resource-container {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 0.25rem;
            max-width: 156px; /* 6 boxes * 20px + 5 gaps * 4px */
        }

        .stat-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            position: relative;
        }
        
        .stat-proficiency {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            position: absolute;
            top: -2px;
            right: -2px;
            border: 2px dashed #9CA3AF;
            background-color: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .stat-proficiency:hover {
            border-color: #6B7280;
        }
        
        .stat-proficiency.proficient {
            border: 2px solid #000;
            background-color: #000;
        }
        
        .dark .stat-proficiency {
            background-color: #374151;
            border-color: #6B7280;
        }
        
        .dark .stat-proficiency:hover {
            border-color: #9CA3AF;
        }
        
        .dark .stat-proficiency.proficient {
            border-color: white;
            background-color: #000;
        }
        
        .proficiency-circle {
            transition: all 0.2s ease;
        }
        
        .proficiency-circle.proficient {
            border-style: solid;
            background-color: black;
            border-color: black;
        }
         .dark .proficiency-circle.proficient {
            border-style: solid;
            background-color: black;
            border-color: white;
        }
        .weapon-proficiency-circle {
            transition: all 0.2s ease;
        }
        
        .weapon-proficiency-circle.proficient {
            border-style: solid;
            background-color: black;
            border-color: black;
        }
        
        .dark .weapon-proficiency-circle.proficient {
            border-style: solid;
            background-color: black;
            border-color: white;
        }
        
        .slide-in {
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .resource-box {
            width: 20px;
            height: 20px;
            border: 2px solid #6B7280;
            background-color: transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .resource-box.solid {
            border: 2px solid #374151;
            border-style: solid;
        }
        
        .resource-box.dotted {
            border: 2px dotted #9CA3AF;
        }
        
        .resource-box.used {
            background-color: #EF4444;
            border-color: #DC2626;
        }
        
        .resource-box.temp {
            border-color: #10B981;
            background-color: transparent;
        }
        
        .resource-box.temp.used {
            background-color: #10B981;
            border-color: #059669;
        }
        
        .resource-box:hover {
            border-color: #5D5CDE;
        }
        
        .dark .resource-box {
            border-color: #9CA3AF;
        }
        
        .dark .resource-box.solid {
            border-color: #E5E7EB;
        }
        
        .dark .resource-box.dotted {
            border-color: #6B7280;
        }
        
        .dark .resource-box.used {
            background-color: #DC2626;
            border-color: #B91C1C;
        }
        
        .dark .resource-box.temp {
            border-color: #10B981;
        }
        
        .dark .resource-box.temp.used {
            background-color: #059669;
            border-color: #047857;
        }

        .threshold-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.125rem;
            text-align: center;
        }
        
        @media (min-width: 768px) {
            .threshold-container {
                gap: 0.5rem;
            }
        }

        .threshold-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .threshold-label {
            font-weight: 600;
            font-size: 0.75rem;
            color: #374151;
            margin-bottom: 0.25rem;
        }

        .dark .threshold-label {
            color: #D1D5DB;
        }

        .threshold-value {
            font-weight: bold;
            font-size: 1.25rem;
            color: #DC2626;
            margin-bottom: 0;
            border: 2px solid #374151;
            padding: 0.5rem;
            border-radius: 0.375rem 0.375rem 0 0;
            background-color: #F9FAFB;
        }

        .dark .threshold-value {
            border-color: #E5E7EB;
            background-color: #1F2937;
            color: #EF4444;
        }

        .threshold-temp-boxes {
            display: flex;
            flex-direction: column;
        }

        .threshold-temp-box {
            width: 100%;
            height: 3rem;
            border: 2px solid #374151;
            border-top: 0;
            background-color: #F3F4F6;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .threshold-temp-box:first-child {
            border-radius: 0;
        }

        .threshold-temp-box:last-child {
            border-radius: 0 0 0.375rem 0.375rem;
        }

        .threshold-temp-box:hover {
            background-color: #5D5CDE;
            color: white;
        }

        .dark .threshold-temp-box {
            border-color: #E5E7EB;
            background-color: #374151;
            color: #D1D5DB;
        }

        .dark .threshold-temp-box:hover {
            background-color: #5D5CDE;
        }

        .threshold-hp {
            font-size: 0.625rem;
            color: #6B7280;
        }

        .dark .threshold-hp {
            color: #9CA3AF;
        }

        .threshold-damage-button {
            background: none;
            border: 2px solid transparent;
            border-radius: 0.375rem;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
        }

        .threshold-damage-button:hover {
            border-color: #EF4444;
            background-color: rgba(239, 68, 68, 0.1);
        }

        .threshold-damage-button:active {
            background-color: rgba(239, 68, 68, 0.2);
            transform: scale(0.98);
        }

        .dark .threshold-damage-button:hover {
            border-color: #DC2626;
            background-color: rgba(220, 38, 38, 0.1);
        }

        .dark .threshold-damage-button:active {
            background-color: rgba(220, 38, 38, 0.2);
        }
        
        .combat-stat-box {
            width: 80px;
            height: 50px;
            border: 2px solid #374151;
            border-radius: 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.25rem;
            background-color: #F9FAFB;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .combat-stat-box:hover {
            background-color: #5D5CDE;
            color: white;
        }
        
        .dark .combat-stat-box {
            border-color: #E5E7EB;
            background-color: #1F2937;
            color: #E5E7EB;
        }
        
        .dark .combat-stat-box:hover {
            background-color: #5D5CDE;
        }
        
        .armor-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px dashed #9CA3AF;
            background-color: transparent;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .armor-circle.solid-border {
            border-style: solid;
            border-color: #374151;
        }
        
        .armor-circle.temp-armor-slot {
            border-color: #10B981;
            position: relative;
        }
        
        .armor-circle.temp-armor-slot::after {
            content: '';
            position: absolute;
            top: -1px;
            right: -1px;
            width: 4px;
            height: 4px;
            background-color: #10B981;
            border-radius: 50%;
        }
        
        .armor-circle.filled {
            background-color: #EF4444;
        }
        
        .armor-circle:hover {
            border-color: #5D5CDE;
            transform: scale(1.1);
        }
        
        .dark .armor-circle {
            border-color: #6B7280;
        }
        
        .dark .armor-circle.solid-border {
            border-color: #E5E7EB;
        }
        
        .dark .armor-circle.temp-armor-slot {
            border-color: #10B981;
        }
        
        .dark .armor-circle:hover {
            border-color: #5D5CDE;
        }

        .race-bonus-button {
            padding: 0.5rem 0.75rem;
            border: 2px solid #D1D5DB;
            border-radius: 0.375rem;
            background-color: #FFFFFF;
            color: #374151;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .race-bonus-button:hover {
            border-color: #5D5CDE;
            background-color: #F3F4F6;
        }

        .race-bonus-button.selected {
            border-color: #5D5CDE;
            background-color: #5D5CDE;
            color: #FFFFFF;
        }

        .dark .race-bonus-button {
            border-color: #6B7280;
            background-color: #374151;
            color: #E5E7EB;
        }

        .dark .race-bonus-button:hover {
            border-color: #5D5CDE;
            background-color: #4B5563;
        }

        .dark .race-bonus-button.selected {
            border-color: #5D5CDE;
            background-color: #5D5CDE;
            color: #FFFFFF;
        }

        .race-proficiency-button {
            padding: 0.375rem 0.75rem;
            border: 2px solid #D1D5DB;
            border-radius: 0.375rem;
            background-color: #FFFFFF;
            color: #374151;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 3rem;
            text-align: center;
        }

        .race-proficiency-button:hover {
            border-color: #5D5CDE;
            background-color: #F3F4F6;
        }

        .race-proficiency-button.selected {
            border-color: #5D5CDE;
            background-color: #5D5CDE;
            color: #FFFFFF;
        }

        .dark .race-proficiency-button {
            border-color: #6B7280;
            background-color: #374151;
            color: #E5E7EB;
        }

        .dark .race-proficiency-button:hover {
            border-color: #5D5CDE;
            background-color: #4B5563;
        }

        .dark .race-proficiency-button.selected {
            border-color: #5D5CDE;
            background-color: #5D5CDE;
            color: #FFFFFF;
        }

        .ability-score-results {
            padding: 0.5rem;
            border: 2px solid #D1D5DB;
            border-radius: 0.375rem;
            background-color: #F9FAFB;
            color: #374151;
            font-size: 0.875rem;
            min-height: 2.5rem;
            max-width: 300px;
            display: flex;
            align-items: center;
        }

        .dark .ability-score-results {
            border-color: #6B7280;
            background-color: #1F2937;
            color: #E5E7EB;
        }

        .ability-checkbox {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            border: 1px solid #D1D5DB;
            border-radius: 0.375rem;
            background-color: #FFFFFF;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .ability-checkbox:hover {
            border-color: #5D5CDE;
            background-color: #F3F4F6;
        }

        .ability-checkbox.selected {
            border-color: #5D5CDE;
            background-color: #EEF2FF;
        }

        .dark .ability-checkbox {
            border-color: #6B7280;
            background-color: #374151;
            color: #E5E7EB;
        }

        .dark .ability-checkbox:hover {
            border-color: #5D5CDE;
            background-color: #4B5563;
        }

        .dark .ability-checkbox.selected {
            border-color: #5D5CDE;
            background-color: #3730A3;
        }

        .points-counter {
            padding: 0.5rem 1rem;
            border: 2px solid #5D5CDE;
            border-radius: 0.375rem;
            background-color: #EEF2FF;
            color: #5D5CDE;
            font-weight: 600;
            text-align: center;
        }

        .dark .points-counter {
            background-color: #3730A3;
            color: #A5B4FC;
        }

        .weapon-item {
            padding: 0.75rem;
            border: 2px solid #D1D5DB;
            border-radius: 0.375rem;
            background-color: #FFFFFF;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .weapon-item:hover {
            border-color: #5D5CDE;
            background-color: #F3F4F6;
        }

        .weapon-item.selected {
            border-color: #5D5CDE;
            background-color: #EEF2FF;
        }

        .dark .weapon-item {
            border-color: #6B7280;
            background-color: #374151;
            color: #E5E7EB;
        }

        .dark .weapon-item:hover {
            border-color: #5D5CDE;
            background-color: #4B5563;
        }

        .dark .weapon-item.selected {
            border-color: #5D5CDE;
            background-color: #3730A3;
        }

        .weapon-display {
            padding: 0.75rem;
            border: 2px solid #374151;
            border-radius: 0.375rem;
            background-color: #F9FAFB;
            position: relative;
        }

        .dark .weapon-display {
            border-color: #E5E7EB;
            background-color: #1F2937;
            color: #E5E7EB;
        }

        .weapon-remove {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            color: #EF4444;
            cursor: pointer;
            font-size: 0.875rem;
        }

        .weapon-remove:hover {
            color: #DC2626;
        }

        .section {
            display: block;
        }
        
        .character-view {
            display: none;
        }
        
        .character-view.active {
            display: block;
        }
        
        .active-tab {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .level-up-option {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            border: 1px solid #D1D5DB;
            border-radius: 0.375rem;
            background-color: #FFFFFF;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .level-up-option:hover {
            border-color: #5D5CDE;
            background-color: #F3F4F6;
        }

        .level-up-option.selected {
            border-color: #5D5CDE;
            background-color: #EEF2FF;
        }

        .dark .level-up-option {
            border-color: #6B7280;
            background-color: #374151;
            color: #E5E7EB;
        }

        .dark .level-up-option:hover {
            border-color: #5D5CDE;
            background-color: #4B5563;
        }

        .dark .level-up-option.selected {
            border-color: #5D5CDE;
            background-color: #3730A3;
        }

        .rest-resource-option {
            transition: all 0.2s ease;
        }

        .rest-resource-option.selected {
            border-color: #5D5CDE;
            background-color: #EEF2FF;
        }

        .dark .rest-resource-option.selected {
            border-color: #5D5CDE;
            background-color: #3730A3;
        }

        /* Media query for smaller screens (e.g., mobile) */
        @media (max-width: 600px) {
          .levelUpCharacter {
            width: 50%; /* Wider button on smaller screens */
            font-size: 1em; /* Slightly smaller font */
            padding: 12px 15px;
          }
        }

        /* Enhanced armor slot status indicator */
        .armor-status-indicator {
            position: absolute;
            bottom: -2px;
            right: -2px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            border: 1px solid white;
        }

        .armor-status-indicator.permanent {
            background-color: #374151;
        }

        .armor-status-indicator.temporary {
            background-color: #10B981;
        }

        .dark .armor-status-indicator {
            border-color: #1F2937;
        }

    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-900 dark:text-white min-h-screen">
<!--    
     Navigation 
    <nav class="bg-primary dark:bg-primary-dark shadow-lg sticky top-0 z-50">
        <div class="max-w-6xl mx-auto px-4">
            <div class="flex justify-between items-center h-16">
                <h1 class="text-white text-xl font-bold">RPG Character Manager</h1>
                <div class="flex space-x-4">
                    <button id="charactersTab" class="text-white hover:text-gray-200 px-3 py-2 rounded active-tab">
                        <i class="fas fa-users mr-2"></i>Characters
                    </button>
                </div>
            </div>
        </div>
    </nav>
 -->

    <!-- Hidden file input for loading characters -->
    <input type="file" id="loadFileInput" accept=".json" style="display: none;">
    <!-- Hidden file input for loading individual character -->
    <input type="file" id="loadSingleCharacterInput" accept=".json" style="display: none;">

    <div class="max-w-6xl mx-auto p-4">
        <!-- Characters Section -->
        <div id="charactersSection" class="section active">
            <!-- Character List -->
            <div id="characterList" class="character-view active">
                <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4">
                    <h2 class="text-2xl font-bold">Your Characters</h2>
                    <div class="flex flex-col sm:flex-row w-full sm:w-auto gap-2 sm:gap-3">
                        <!-- Save/Load buttons - side by side on mobile, to the left on desktop -->
                        <div class="flex gap-2 order-1 sm:order-none">
                            <button id="saveCharactersBtn" class="bg-green-500 hover:bg-green-600 text-white px-3 md:px-4 py-2 rounded-lg transition-colors text-sm md:text-base flex-1 sm:flex-none">
                                <i class="fas fa-download mr-1 md:mr-2"></i><span class="sm:hidden md:hidden lg:hidden">Save</span><span class="hidden sm:inline md:inline lg:hidden">Save</span><span class="hidden lg:inline">Save All</span>
                            </button>
                            <button id="loadCharactersBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-3 md:px-4 py-2 rounded-lg transition-colors text-sm md:text-base flex-1 sm:flex-none">
                                <i class="fas fa-upload mr-1 md:mr-2"></i><span class="sm:hidden md:hidden lg:hidden">Load</span><span class="hidden sm:inline md:inline lg:hidden">Load</span><span class="hidden lg:inline">Load All</span>
                            </button>
                        </div>
                        <!-- Existing buttons -->
                        <div class="flex gap-2 sm:gap-3 order-2 sm:order-none">
                            <button id="makeRandomBtn" class="bg-purple-500 hover:bg-purple-600 text-white px-3 md:px-4 py-2 rounded-lg transition-colors text-sm md:text-base flex-1 sm:flex-none">
                                <i class="fas fa-dice mr-1 md:mr-2"></i><span class="sm:hidden md:hidden lg:inline">Random</span><span class="hidden sm:inline md:inline lg:hidden">Random</span><span class="hidden lg:inline">Make a Random</span>
                            </button>
                            <button id="newCharacterBtn" class="bg-primary hover:bg-primary-dark text-white px-3 md:px-4 py-2 rounded-lg transition-colors text-sm md:text-base flex-1 sm:flex-none">
                                <i class="fas fa-plus mr-1 md:mr-2"></i><span class="sm:hidden md:hidden lg:inline">New</span><span class="hidden sm:inline md:inline lg:hidden">New</span><span class="hidden lg:inline">New Character</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div id="characterCards" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Character cards will be inserted here -->
                </div>
                
                <div id="noCharacters" class="text-center py-12 text-gray-500 dark:text-gray-400">
                    <i class="fas fa-user-plus text-6xl mb-4"></i>
                    <h3 class="text-xl font-semibold mb-2">No Characters Yet</h3>
                    <p>Create your first character to get started!</p>
                </div>
            </div>

            <!-- Character Creation -->
            <div id="characterCreation" class="character-view">
                <div class="flex items-center mb-6">
                    <button id="backToList" class="text-primary hover:text-primary-dark mr-4">
                        <i class="fas fa-arrow-left text-xl"></i>
                    </button>
                    <h2 class="text-2xl font-bold">Create Character</h2>
                </div>

                <form id="characterForm" class="space-y-6">
                    <!-- Basic Info -->
                    <div class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-lg font-semibold mb-4">Basic Information</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium mb-2">Character Name</label>
                                <input type="text" id="charName" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent" required>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Level</label>
                                <input type="number" id="charLevel" value="1" min="1" max="10" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent" disabled>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Race</label>
                                <select id="charRace" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                    <option>--</option>
                                    <option>Assaimar</option>
                                    <option>Dragonborn</option>
                                    <option>Dwarf</option>
                                    <option>Elf</option>
                                    <option>Gnome</option>
                                    <option>Halfling</option>
                                    <option>Human</option>
                                    <option>Orc</option>
                                    <option>Tiefling</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Class</label>
                                <select id="charClass" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                    <option>--</option>
                                    <option>Barbarian</option>
                                    <option>Bard</option>
                                    <option>Cleric</option>
                                    <option>Druid</option>
                                    <option>Fighter</option>
                                    <option>Monk</option>
                                    <option>Paladin</option>
                                    <option>Ranger</option>
                                    <option>Rogue</option>
                                    <option>Sorcerer</option>
                                    <option>Warlock</option>
                                    <option>Wizard</option>
                                </select>
                            </div>
                        </div>

                        <!-- Race Bonuses and Proficiencies Combined -->
                        <div id="raceBonusSection" class="mt-4 hidden">
                            <label class="block text-sm font-medium mb-2">Race Bonuses & Ability Scores (Select up to 2)</label>
                            <div id="raceBonusButtons" class="flex flex-wrap gap-2">
                                <!-- Race bonus and ability score buttons will be populated here -->
                            </div>
                        </div>

                        <!-- Race Proficiencies -->
                        <div id="raceProficiencySection" class="mt-4 hidden">
                            <label class="block text-sm font-medium mb-2">Race Proficiencies (Select up to 2)</label>
                            <div id="raceProficiencyButtons" class="flex flex-wrap gap-2">
                                <!-- Race proficiency buttons will be populated here -->
                            </div>
                        </div>

                        <!-- Ability Score Results -->
                        <div id="abilityScoreResultsSection" class="mt-4 hidden">
                            <label class="block text-sm font-medium mb-2">Selected Ability Scores</label>
                            <div id="abilityScoreResults" class="ability-score-results empty">
                                No ability scores selected
                            </div>
                        </div>
                    </div>

                    <!-- Familiar Section (for Wizard and Warlock) -->
                    <div id="familiarSection" class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg" style="display: none;">
                        <h3 class="text-lg font-semibold mb-4">Familiar</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="flex items-center cursor-pointer">
                                    <input type="checkbox" id="hasFamiliar" class="mr-2">
                                    <span class="text-sm font-medium">Yes, I want a familiar</span>
                                </label>
                            </div>
                            <div id="familiarNameSection" class="hidden">
                                <label class="block text-sm font-medium mb-2">Familiar Name</label>
                                <input type="text" id="familiarName" placeholder="Familiar" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                        </div>
                    </div>

                    <!-- Ranger Companion Section (for Ranger) -->
                    <div id="companionSection" class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg" style="display: none;">
                        <h3 class="text-lg font-semibold mb-4">Ranger Companion</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="flex items-center cursor-pointer">
                                    <input type="checkbox" id="hasCompanion" class="mr-2">
                                    <span class="text-sm font-medium">Yes, I want a companion</span>
                                </label>
                            </div>
                            <div id="companionDetailsSection" class="hidden space-y-4">
                                <div>
                                    <label class="block text-sm font-medium mb-2">Companion Name</label>
                                    <input type="text" id="companionName" placeholder="Companion" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium mb-2">Companion Type</label>
                                    <select id="companionType" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                        <option value="">-- Select Companion Type --</option>
                                        <option value="Bear">Bear</option>
                                        <option value="Great Cat">Great Cat</option>
                                        <option value="Wolf">Wolf</option>
                                        <option value="Hawk">Hawk</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Ability Scores -->
                    <div class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-semibold">Ability Scores</h3>
                            <div class="flex space-x-2">
                                <button type="button" id="randomizeModifiers" class="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1 rounded text-sm">
                                    <i class="fas fa-dice mr-1"></i>Randomize
                                </button>
                                <button type="button" id="resetModifiers" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm">
                                    <i class="fas fa-redo mr-1"></i>Reset
                                </button>
                            </div>
                        </div>
                        <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded-lg">
                            <p class="text-sm text-blue-800 dark:text-blue-200 mb-2">Available Modifiers:</p>
                            <div id="availableModifiers" class="flex flex-wrap gap-2">
                                <!-- Available modifiers will be shown here -->
                            </div>
                        </div>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Strength</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="str">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="str" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Dexterity</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="dex">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="dex" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Constitution</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="con">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="con" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Intelligence</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="int">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="int" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Wisdom</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="wis">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="wis" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Charisma</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="cha">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="cha" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Resources -->
                    <div class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-lg font-semibold mb-4">Resources</h3>
                        <div class="space-y-4">
                            <!-- HP -->
                            <div class="flex items-center space-x-4">
                                <div class="w-16 text-sm font-medium">HP</div>
                                <div class="resource-container" id="hpBoxes">
                                    <!-- HP boxes will be generated here -->
                                </div>
                                <input type="number" id="hpMax" value="0" min="0" max="12" class="w-16 px-2 py-1 text-base text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            
                            <!-- Separator Line -->
                                <div class="border-t border-gray-300 dark:border-gray-600 my-4"></div>

                            <!-- STRESS -->
                            <div class="flex items-center space-x-4">
                                <div class="w-16 text-sm font-medium">STRESS</div>
                                <div class="resource-container" id="stressBoxes">
                                    <!-- Stress boxes will be generated here -->
                                </div>
                                <input type="number" id="stressMax" value="0" min="0" max="12" class="w-16 px-2 py-1 text-base text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            
                            <!-- Separator Line -->
                                <div class="border-t border-gray-300 dark:border-gray-600 my-4"></div>

                            <!-- CLASS -->
                            <div class="flex items-center space-x-4">
                                <div class="w-16 text-sm font-medium">CLASS</div>
                                <div class="resource-container" id="classBoxes">
                                    <!-- Class boxes will be generated here -->
                                </div>
                                <input type="number" id="classMax" value="0" min="0" max="12" class="w-16 px-2 py-1 text-base text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            
                            <!-- Separator Line -->
                                <div class="border-t border-gray-300 dark:border-gray-600 my-4"></div>

                            <!-- SPELL -->
                            <div class="flex items-center space-x-4">
                                <div class="w-16 text-sm font-medium">SPELL</div>
                                <div class="resource-container" id="spellBoxes">
                                    <!-- Spell boxes will be generated here -->
                                </div>
                                <input type="number" id="spellMax" value="0" min="0" max="12" class="w-16 px-2 py-1 text-base text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                        </div>
                        
                        <!-- Combat Stats -->
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6 pt-4 border-t border-gray-200 dark:border-gray-700">
                            <div>
                                <label class="block text-sm font-medium mb-2">Evasion</label>
                                <input type="number" id="evasion" value="0" min="1" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Armor</label>
                                <input type="number" id="armor" value="1" min="0" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                        </div>
                    </div>

                    <!-- Threshold -->
                    <div class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-lg font-semibold mb-4">Threshold</h3>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium mb-2">Lower</label>
                                <input type="number" id="thresholdLower" value="0" min="0" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Upper</label>
                                <input type="number" id="thresholdUpper" value="0" min="0" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end space-x-4">
                        <button type="button" id="cancelCreate" class="px-6 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors">
                            Cancel
                        </button>
                        <button type="submit" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">
                            Create Character
                        </button>
                    </div>
                </form>
            </div>

            <!-- Character Edit -->
            <div id="characterEdit" class="character-view">
                <div class="flex items-center mb-6">
                    <button id="backToSheetFromEdit" class="text-primary hover:text-primary-dark mr-4">
                        <i class="fas fa-arrow-left text-xl"></i>
                    </button>
                    <h2 class="text-2xl font-bold">Edit Character</h2>
                </div>

                <form id="editCharacterForm" class="space-y-6">
                    <!-- Basic Info -->
                    <div class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-lg font-semibold mb-4">Basic Information</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium mb-2">Character Name</label>
                                <input type="text" id="editCharName" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent" required>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Level</label>
                                <input type="number" id="editCharLevel" value="1" min="1" max="10" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Race</label>
                                <select id="editCharRace" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                    <option>--</option>
                                    <option>Assaimar</option>
                                    <option>Dragonborn</option>
                                    <option>Dwarf</option>
                                    <option>Elf</option>
                                    <option>Gnome</option>
                                    <option>Halfling</option>
                                    <option>Human</option>
                                    <option>Orc</option>
                                    <option>Tiefling</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Class</label>
                                <select id="editCharClass" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                    <option>--</option>
                                    <option>Barbarian</option>
                                    <option>Bard</option>
                                    <option>Cleric</option>
                                    <option>Druid</option>
                                    <option>Fighter</option>
                                    <option>Monk</option>
                                    <option>Paladin</option>
                                    <option>Ranger</option>
                                    <option>Rogue</option>
                                    <option>Sorcerer</option>
                                    <option>Warlock</option>
                                    <option>Wizard</option>
                                </select>
                            </div>
                        </div>

                        <!-- Race Bonuses and Proficiencies Combined -->
                        <div id="editRaceBonusSection" class="mt-4 hidden">
                            <label class="block text-sm font-medium mb-2">Race Bonuses & Ability Scores (Select up to 2)</label>
                            <div id="editRaceBonusButtons" class="flex flex-wrap gap-2">
                                <!-- Race bonus and ability score buttons will be populated here -->
                            </div>
                        </div>

                        <!-- Race Proficiencies -->
                        <div id="editRaceProficiencySection" class="mt-4 hidden">
                            <label class="block text-sm font-medium mb-2">Race Proficiencies (Select up to 2)</label>
                            <div id="editRaceProficiencyButtons" class="flex flex-wrap gap-2">
                                <!-- Race proficiency buttons will be populated here -->
                            </div>
                        </div>

                        <!-- Ability Score Results -->
                        <div id="editAbilityScoreResultsSection" class="mt-4 hidden">
                            <label class="block text-sm font-medium mb-2">Selected Ability Scores</label>
                            <div id="editAbilityScoreResults" class="ability-score-results empty">
                                No ability scores selected
                            </div>
                        </div>
                    </div>

                    <!-- Familiar Section (for Wizard and Warlock) -->
                    <div id="editFamiliarSection" class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg" style="display: none;">
                        <h3 class="text-lg font-semibold mb-4">Familiar</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="flex items-center cursor-pointer">
                                    <input type="checkbox" id="editHasFamiliar" class="mr-2">
                                    <span class="text-sm font-medium">Yes, I want a familiar</span>
                                </label>
                            </div>
                            <div id="editFamiliarNameSection" class="hidden">
                                <label class="block text-sm font-medium mb-2">Familiar Name</label>
                                <input type="text" id="editFamiliarName" placeholder="Familiar" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                        </div>
                    </div>

                    <!-- Ranger Companion Section (for Ranger) -->
                    <div id="editCompanionSection" class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg" style="display: none;">
                        <h3 class="text-lg font-semibold mb-4">Ranger Companion</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="flex items-center cursor-pointer">
                                    <input type="checkbox" id="editHasCompanion" class="mr-2">
                                    <span class="text-sm font-medium">Yes, I want a companion</span>
                                </label>
                            </div>
                            <div id="editCompanionDetailsSection" class="hidden space-y-4">
                                <div>
                                    <label class="block text-sm font-medium mb-2">Companion Name</label>
                                    <input type="text" id="editCompanionName" placeholder="Companion" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium mb-2">Companion Type</label>
                                    <select id="editCompanionType" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                        <option value="">-- Select Companion Type --</option>
                                        <option value="Bear">Bear</option>
                                        <option value="Great Cat">Great Cat</option>
                                        <option value="Wolf">Wolf</option>
                                        <option value="Hawk">Hawk</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Ability Scores -->
                    <div class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-semibold">Ability Scores</h3>
                            <div class="flex space-x-2">
                                <button type="button" id="editRandomizeModifiers" class="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1 rounded text-sm">
                                    <i class="fas fa-dice mr-1"></i>Randomize
                                </button>
                                <button type="button" id="editResetModifiers" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm">
                                    <i class="fas fa-redo mr-1"></i>Reset
                                </button>
                            </div>
                        </div>

                        <!-- Manual Ability Score Input -->
                        <div class="mb-4 p-3 bg-yellow-50 dark:bg-yellow-900 rounded-lg">
                            <h4 class="text-sm font-semibold text-yellow-800 dark:text-yellow-200 mb-2">Direct Input</h4>
                            <div class="grid grid-cols-3 md:grid-cols-6 gap-2">
                                <div class="text-center">
                                    <label class="block text-xs font-medium mb-1">STR</label>
                                    <input type="number" id="editStrInput" min="-5" max="10" class="w-full px-2 py-1 text-sm text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                </div>
                                <div class="text-center">
                                    <label class="block text-xs font-medium mb-1">DEX</label>
                                    <input type="number" id="editDexInput" min="-5" max="10" class="w-full px-2 py-1 text-sm text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                </div>
                                <div class="text-center">
                                    <label class="block text-xs font-medium mb-1">CON</label>
                                    <input type="number" id="editConInput" min="-5" max="10" class="w-full px-2 py-1 text-sm text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                </div>
                                <div class="text-center">
                                    <label class="block text-xs font-medium mb-1">INT</label>
                                    <input type="number" id="editIntInput" min="-5" max="10" class="w-full px-2 py-1 text-sm text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                </div>
                                <div class="text-center">
                                    <label class="block text-xs font-medium mb-1">WIS</label>
                                    <input type="number" id="editWisInput" min="-5" max="10" class="w-full px-2 py-1 text-sm text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                </div>
                                <div class="text-center">
                                    <label class="block text-xs font-medium mb-1">CHA</label>
                                    <input type="number" id="editChaInput" min="-5" max="10" class="w-full px-2 py-1 text-sm text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                                </div>
                            </div>
                        </div>

                        <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded-lg">
                            <p class="text-sm text-blue-800 dark:text-blue-200 mb-2">Available Modifiers:</p>
                            <div id="editAvailableModifiers" class="flex flex-wrap gap-2">
                                <!-- Available modifiers will be shown here -->
                            </div>
                        </div>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Strength</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="edit-ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="str">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="edit-proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="str" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Dexterity</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="edit-ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="dex">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="edit-proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="dex" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Constitution</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="edit-ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="con">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="edit-proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="con" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Intelligence</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="edit-ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="int">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="edit-proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="int" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Wisdom</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="edit-ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="wis">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="edit-proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="wis" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                            <div class="text-center">
                                <label class="block text-sm font-medium mb-2">Charisma</label>
                                <div class="flex items-center justify-center space-x-2">
                                    <button type="button" class="edit-ability-selector w-16 h-10 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:ring-2 focus:ring-primary focus:border-transparent transition-colors" data-ability="cha">
                                        <span class="modifier-display">--</span>
                                    </button>
                                    <div class="edit-proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent opacity-50 cursor-not-allowed transition-colors" data-ability="cha" title="Proficiency set by race selection">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Resources -->
                    <div class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-lg font-semibold mb-4">Resources</h3>
                        <div class="space-y-4">
                            <!-- HP -->
                            <div class="flex items-center space-x-4">
                                <div class="w-16 text-sm font-medium">HP</div>
                                <div class="resource-container" id="editHpBoxes">
                                    <!-- HP boxes will be generated here -->
                                </div>
                                <input type="number" id="editHpMax" value="0" min="0" max="12" class="w-16 px-2 py-1 text-base text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            
                            <!-- Separator Line -->
                                <div class="border-t border-gray-300 dark:border-gray-600 my-4"></div>

                            <!-- STRESS -->
                            <div class="flex items-center space-x-4">
                                <div class="w-16 text-sm font-medium">STRESS</div>
                                <div class="resource-container" id="editStressBoxes">
                                    <!-- Stress boxes will be generated here -->
                                </div>
                                <input type="number" id="editStressMax" value="0" min="0" max="12" class="w-16 px-2 py-1 text-base text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            
                            <!-- Separator Line -->
                                <div class="border-t border-gray-300 dark:border-gray-600 my-4"></div>

                            <!-- CLASS -->
                            <div class="flex items-center space-x-4">
                                <div class="w-16 text-sm font-medium">CLASS</div>
                                <div class="resource-container" id="editClassBoxes">
                                    <!-- Class boxes will be generated here -->
                                </div>
                                <input type="number" id="editClassMax" value="0" min="0" max="12" class="w-16 px-2 py-1 text-base text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            
                            <!-- Separator Line -->
                                <div class="border-t border-gray-300 dark:border-gray-600 my-4"></div>

                            <!-- SPELL -->
                            <div class="flex items-center space-x-4">
                                <div class="w-16 text-sm font-medium">SPELL</div>
                                <div class="resource-container" id="editSpellBoxes">
                                    <!-- Spell boxes will be generated here -->
                                </div>
                                <input type="number" id="editSpellMax" value="0" min="0" max="12" class="w-16 px-2 py-1 text-base text-center border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                        </div>
                        
                        <!-- Combat Stats -->
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6 pt-4 border-t border-gray-200 dark:border-gray-700">
                            <div>
                                <label class="block text-sm font-medium mb-2">Evasion</label>
                                <input type="number" id="editEvasion" value="0" min="1" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Armor</label>
                                <input type="number" id="editArmor" value="1" min="0" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                        </div>
                    </div>

                    <!-- Threshold -->
                    <div class="bg-gray-50 dark:bg-gray-800 p-6 rounded-lg">
                        <h3 class="text-lg font-semibold mb-4">Threshold</h3>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-sm font-medium mb-2">Lower</label>
                                <input type="number" id="editThresholdLower" value="0" min="0" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Upper</label>
                                <input type="number" id="editThresholdUpper" value="0" min="0" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end space-x-4">
                        <button type="button" id="cancelEdit" class="px-6 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded-lg transition-colors">
                            Cancel
                        </button>
                        <button type="submit" class="bg-primary hover:bg-primary-dark text-white px-6 py-2 rounded-lg transition-colors">
                            Update Character
                        </button>
                    </div>
                </form>
            </div>

            <!-- Character Sheet -->
            <div id="characterSheet" class="character-view">
                <div class="flex items-center mb-4">
                    <button id="backToListFromSheet" class="text-primary hover:text-primary-dark mr-4">
                        <i class="fas fa-arrow-left text-xl"></i>
                    </button>
                    <div class="flex-1">
                        <div class="flex items-center">
                            <h2 id="sheetCharName" class="text-2xl font-bold mr-3"></h2>
                            <button id="editCharacterBtn" class="text-gray-500 hover:text-primary dark:text-gray-400 dark:hover:text-primary transition-colors" title="Edit Character">
                                <i class="fas fa-edit text-lg"></i>
                            </button>
                        </div>
                        <p id="sheetCharInfo" class="text-gray-600 dark:text-gray-400"></p>
                    </div>
                </div>

                <!-- Character Actions Section -->
                <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg mb-6">
                    <h3 class="font-semibold mb-3 text-center">Character Actions</h3>
                    <div class="flex flex-wrap justify-center gap-3">
                        <button id="restCharacter" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded text-sm font-medium transition-colors flex items-center justify-center min-w-[100px]">
                            <i class="fas fa-bed mr-1"></i>Rest
                        </button>
                        <button id="levelUpCharacter" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded text-sm font-medium transition-colors flex items-center justify-center min-w-[100px]">
                            <i class="fas fa-arrow-up mr-1"></i>Level Up
                        </button>
                        <button id="saveCharacter" class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded text-sm font-medium transition-colors flex items-center justify-center min-w-[100px]">
                            <i class="fas fa-download mr-1"></i>Save
                        </button>
                        <button id="deleteCharacter" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded text-sm font-medium transition-colors flex items-center justify-center min-w-[100px]">
                            <i class="fas fa-trash mr-1"></i>Delete
                        </button>
                    </div>
                </div>

                <!-- Character Sheet Content -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <!-- Left Column: Combat Stats, Resources, and Threshold -->
                    <div class="space-y-6">
                        <!-- Combat Stats -->
                        <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                            <h3 class="font-semibold mb-3">Combat Stats</h3>
                            <div class="flex items-center space-x-3 mb-4">
                                <div class="text-center">
                                    <div class="text-xs font-medium mb-1">Evasion</div>
                                    <div class="combat-stat-box" id="displayEvasion"></div>
                                </div>
                                <div class="text-center">
                                    <div class="text-xs font-medium mb-1">Armor</div>
                                    <div class="combat-stat-box" id="displayArmor"></div>
                                </div>
                                <div class="flex-1">
                                    <div class="text-center mb-2">
                                        <div class="text-xs font-medium">Armor Slots</div>
                                        <div class="text-xs text-gray-500 dark:text-gray-400">
                                            <span id="armorSlotsCount">0/0</span>
                                            <span class="mx-1">|</span>
                                            <span class="text-green-600 dark:text-green-400" id="tempArmorCount">+0 temp</span>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-3 gap-1" id="armorCircles">
                                        <!-- 12 armor circles will be generated here -->
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Unarmored Defense -->
                            <div id="unarmoredDefenseSection" class="mt-4 p-3 bg-blue-50 dark:bg-blue-900 rounded-lg" style="display: none;">
                                <label class="flex items-center cursor-pointer">
                                    <input type="checkbox" id="unarmoredDefenseToggle" class="mr-2">
                                    <span class="text-sm font-medium text-blue-800 dark:text-blue-200">Unarmored Defense</span>
                                </label>
                                <div class="text-xs text-blue-600 dark:text-blue-300 mt-1" id="unarmoredDefenseDescription">
                                    <!-- Description will be populated based on class -->
                                </div>
                            </div>
                            
                            <!-- Mage Armor -->
                            <div id="mageArmorSection" class="mt-4 p-3 bg-purple-50 dark:bg-purple-900 rounded-lg" style="display: none;">
                                <label class="flex items-center cursor-pointer">
                                    <input type="checkbox" id="mageArmorToggle" class="mr-2">
                                    <span class="text-sm font-medium text-purple-800 dark:text-purple-200">Mage Armor</span>
                                </label>
                                <div class="text-xs text-purple-600 dark:text-purple-300 mt-1" id="mageArmorDescription">
                                    Add DEX modifier to Evasion and Level/2Level to Thresholds
                                </div>
                            </div>
                        </div>

                        <!-- Resources -->
                        <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                            <h3 class="font-semibold mb-3">Resources</h3>
                            <div class="space-y-3">
                                <!-- HP -->
                                <div class="flex items-center space-x-2">
                                    <div class="w-12 text-xs font-medium">HP</div>
                                    <div class="resource-container" id="sheetHpBoxes">
                                        <!-- HP boxes will be generated here -->
                                    </div>
                                </div>
                                
                                <!-- Separator Line -->
                                <div class="border-t border-gray-300 dark:border-gray-600 my-4"></div>

                                <!-- STRESS -->
                                <div class="flex items-center space-x-2">
                                    <div class="w-12 text-xs font-medium">STRESS</div>
                                    <div class="resource-container" id="sheetStressBoxes">
                                        <!-- Stress boxes will be generated here -->
                                    </div>
                                </div>
                                
                                <!-- Separator Line -->
                                <div class="border-t border-gray-300 dark:border-gray-600 my-4"></div>

                                <!-- CLASS -->
                                <div class="flex items-center space-x-2">
                                    <div class="w-12 text-xs font-medium">CLASS</div>
                                    <div class="resource-container" id="sheetClassBoxes">
                                        <!-- Class boxes will be generated here -->
                                    </div>
                                </div>
                                
                                <!-- Separator Line -->
                                <div class="border-t border-gray-300 dark:border-gray-600 my-4"></div>

                                <!-- SPELL -->
                                <div class="flex items-center space-x-2">
                                    <div class="w-12 text-xs font-medium">SPELL</div>
                                    <div class="resource-container" id="sheetSpellBoxes">
                                        <!-- Spell boxes will be generated here -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Threshold -->
                        <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                            <h3 class="font-semibold mb-3">Threshold</h3>
                            <div class="threshold-container">
                                <div class="threshold-section">
                                    <button class="threshold-damage-button" data-damage="1" title="Apply 1 HP damage">
                                        <div class="threshold-label">MINOR DAMAGE</div>
                                        <div class="threshold-hp">Mark 1 HP</div>
                                    </button>
                                </div>
                                <div>
                                    <div class="threshold-value" id="thresholdLowerDisplay">0</div>
                                    <div class="threshold-temp-boxes">
                                        <div class="threshold-temp-box" data-threshold="lower" id="thresholdLowerTemp1">-</div>
                                      
                                    </div>
                                </div>
                                <div class="threshold-section">
                                    <button class="threshold-damage-button" data-damage="2" title="Apply 2 HP damage">
                                        <div class="threshold-label">MAJOR DAMAGE</div>
                                        <div class="threshold-hp">Mark 2 HP</div>
                                    </button>
                                </div>
                                <div>
                                    <div class="threshold-value" id="thresholdUpperDisplay">0</div>
                                    <div class="threshold-temp-boxes">
                                        <div class="threshold-temp-box" data-threshold="upper" id="thresholdUpperTemp1">-</div>
                                  
                                    </div>
                                </div>
                                <div class="threshold-section">
                                    <button class="threshold-damage-button" data-damage="3" title="Apply 3 HP damage">
                                        <div class="threshold-label">SEVERE DAMAGE</div>
                                        <div class="threshold-hp">Mark 3 HP</div>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Familiar -->
                        <div id="familiarSheetSection" class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg" style="display: none;">
                            <div class="flex justify-between items-center mb-3">
                                <h3 class="font-semibold">Familiar</h3>
                                <button id="familiarToggle" class="w-6 h-6 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 rounded flex items-center justify-center transition-colors">
                                    <i class="fas fa-minus text-xs"></i>
                                </button>
                            </div>
                            <div id="familiarContent">
                                <div id="familiarDisplayName" class="text-center font-medium mb-3">Familiar</div>
                                <div class="flex justify-between items-center">
                                    <!-- HP Section -->
                                    <div class="flex flex-col items-center">
                                        <div class="text-xs font-medium mb-1">HP</div>
                                        <div class="resource-box solid cursor-pointer" id="familiarHpBox" data-familiar-resource="hp"></div>
                                    </div>
                                    
                                    <!-- Stress Section -->
                                    <div class="flex flex-col items-center">
                                        <div class="text-xs font-medium mb-1">Stress</div>
                                        <div class="flex gap-1">
                                            <div class="resource-box solid cursor-pointer" id="familiarStressBox1" data-familiar-resource="stress"></div>
                                            <div class="resource-box solid cursor-pointer" id="familiarStressBox2" data-familiar-resource="stress"></div>
                                        </div>
                                    </div>
                                    
                                    <!-- Evasion Section -->
                                    <div class="flex flex-col items-center">
                                        <div class="text-xs font-medium mb-1">Evasion</div>
                                        <div class="text-sm font-medium">10</div>
                                    </div>
                                    
                                    <!-- Modifier Section -->
                                    <div class="flex flex-col items-center">
                                        <div class="text-xs font-medium mb-1">Mod</div>
                                        <div class="text-sm font-medium">+2</div>
                                    </div>
                                    
                                    <!-- Threshold Section -->
                                    <div class="flex flex-col items-center">
                                        <div class="text-xs font-medium mb-1">Threshold</div>
                                        <div class="text-sm font-medium">3 / 6</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Companion -->
                        <div id="companionSheetSection" class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg" style="display: none;">
                            <div class="flex justify-between items-center mb-3">
                                <h3 class="font-semibold">Companion</h3>
                                <button id="companionToggle" class="w-6 h-6 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 rounded flex items-center justify-center transition-colors">
                                    <i class="fas fa-minus text-xs"></i>
                                </button>
                            </div>
                            <div id="companionContent">
                                <div id="companionDisplayName" class="text-center font-medium mb-2">Companion</div>
                                <div id="companionDisplayType" class="text-center text-sm text-gray-600 dark:text-gray-400 mb-3">Bear</div>
                                <div class="flex justify-between items-center text-xs">
                                    <!-- HP Section -->
                                    <div class="flex flex-col items-center">
                                        <div class="text-xs font-medium mb-1">HP</div>
                                        <div class="flex gap-1" id="companionHpBoxes">
                                            <!-- HP boxes will be generated here -->
                                        </div>
                                    </div>
                                    
                                    <!-- Stress Section -->
                                    <div class="flex flex-col items-center">
                                        <div class="text-xs font-medium mb-1">Stress</div>
                                        <div class="flex gap-1" id="companionStressBoxes">
                                            <!-- Stress boxes will be generated here -->
                                        </div>
                                    </div>
                                    
                                    <!-- Evasion Section -->
                                    <div class="flex flex-col items-center">
                                        <div class="text-xs font-medium mb-1">Evasion</div>
                                        <div class="text-sm font-medium" id="companionEvasion">10</div>
                                    </div>
                                    
                                    <!-- Modifier Section -->
                                    <div class="flex flex-col items-center">
                                        <div class="text-xs font-medium mb-1">Mod</div>
                                        <div class="text-sm font-medium" id="companionMod">+2</div>
                                    </div>
                                    
                                    <!-- Threshold Section -->
                                    <div class="flex flex-col items-center">
                                        <div class="text-xs font-medium mb-1">Threshold</div>
                                        <div class="text-sm font-medium" id="companionThreshold">5 / 10</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Middle Column: Ability Scores and Skills -->
                    <div class="space-y-6">
                        <!-- Ability Scores -->
                        <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                            <h3 class="font-semibold mb-3">Ability Scores</h3>
                            <div class="grid grid-cols-2 gap-3">
                                <div class="text-center">
                                    <div class="stat-circle bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-200 mx-auto mb-1">
                                        <span id="displayStr"></span>
                                        <div class="stat-proficiency" data-ability="str"></div>
                                    </div>
                                    <div class="text-xs">STR</div>
                                </div>
                                <div class="text-center">
                                    <div class="stat-circle bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-200 mx-auto mb-1">
                                        <span id="displayDex"></span>
                                        <div class="stat-proficiency" data-ability="dex"></div>
                                    </div>
                                    <div class="text-xs">DEX</div>
                                </div>
                                <div class="text-center">
                                    <div class="stat-circle bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 mx-auto mb-1">
                                        <span id="displayCon"></span>
                                        <div class="stat-proficiency" data-ability="con"></div>
                                    </div>
                                    <div class="text-xs">CON</div>
                                </div>
                                <div class="text-center">
                                    <div class="stat-circle bg-purple-100 dark:bg-purple-900 text-purple-800 dark:text-purple-200 mx-auto mb-1">
                                        <span id="displayInt"></span>
                                        <div class="stat-proficiency" data-ability="int"></div>
                                    </div>
                                    <div class="text-xs">INT</div>
                                </div>
                                <div class="text-center">
                                    <div class="stat-circle bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 mx-auto mb-1">
                                        <span id="displayWis"></span>
                                        <div class="stat-proficiency" data-ability="wis"></div>
                                    </div>
                                    <div class="text-xs">WIS</div>
                                </div>
                                <div class="text-center">
                                    <div class="stat-circle bg-pink-100 dark:bg-pink-900 text-pink-800 dark:text-pink-200 mx-auto mb-1">
                                        <span id="displayCha"></span>
                                        <div class="stat-proficiency" data-ability="cha"></div>
                                    </div>
                                    <div class="text-xs">CHA</div>
                                </div>
                            </div>
                        </div>

                        <!-- Skills -->
                        <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                            <h3 class="font-semibold mb-3">Skills</h3>
                            <div class="space-y-2" id="skillsList">
                                <!-- Skills will be generated here -->
                            </div>
                        </div>
                    </div>

                    <!-- Right Column: Weapons, Equipment and Notes -->
                    <div class="space-y-6">
                      
                        <!-- Weapons and Armor -->
                        <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                               <div class="max-w-md mx-auto">
                                    <!--Weapon Proficiency Toggles Here-->
                                    <h3 class="font-semibold mb-3 text-gray-800 dark:text-gray-200" style="text-align: center">Weapons Proficiency</h3>
                                    <div id="weapon-circles-container" class="flex justify-center gap-3"></div>
                                </div>
                              <!-- Separator Line -->
                                <div class="border-t border-gray-300 dark:border-gray-600 my-4"></div>
                            <h3 class="font-semibold mb-3">Weapons and Armor</h3>
                            <div class="space-y-4">
                                <!-- Primary Weapon -->
                                <div>
                                    <label class="block text-sm font-medium mb-2">Primary</label>
                                    <div id="primaryWeaponDisplay">
                                        <button id="addPrimaryWeapon" class="w-full px-3 py-2 border border-dashed border-gray-400 dark:border-gray-500 rounded text-sm text-gray-600 dark:text-gray-400 hover:border-primary hover:text-primary transition-colors">
                                            <i class="fas fa-plus mr-1"></i>Add Primary Weapon
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Secondary Weapon -->
                                <div>
                                    <label class="block text-sm font-medium mb-2">Secondary</label>
                                    <div id="secondaryWeaponDisplay">
                                        <button id="addSecondaryWeapon" class="w-full px-3 py-2 border border-dashed border-gray-400 dark:border-gray-500 rounded text-sm text-gray-600 dark:text-gray-400 hover:border-primary hover:text-primary transition-colors">
                                            <i class="fas fa-plus mr-1"></i>Add Secondary Weapon
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Separator Line -->
                                <div class="border-t border-gray-300 dark:border-gray-600 my-4"></div>
                                
                                <!-- Armor -->
                                <div>
                                    <label class="block text-sm font-medium mb-2">Armor</label>
                                    <div id="armorDisplay">
                                        <button id="addArmor" class="w-full px-3 py-2 border border-dashed border-gray-400 dark:border-gray-500 rounded text-sm text-gray-600 dark:text-gray-400 hover:border-primary hover:text-primary transition-colors">
                                            <i class="fas fa-plus mr-1"></i>Add Armor
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Equipment -->
                        <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                            <div class="flex justify-between items-center mb-3">
                                <h3 class="font-semibold">Equipment</h3>
                                <button id="addEquipment" class="text-primary hover:text-primary-dark text-sm">
                                    <i class="fas fa-plus mr-1"></i>Add
                                </button>
                            </div>

                            <!-- Health Potions Section -->
                            <div class="mb-4 p-3 bg-red-50 dark:bg-red-900 rounded-lg">
                                <h4 class="font-medium text-red-800 dark:text-red-200 mb-2">Health Potions</h4>
                                <div class="flex items-center justify-between">
                                    <div class="flex space-x-2" id="healthPotionCircles">
                                        <!-- 4 health potion circles will be generated here -->
                                    </div>
                                    <button id="useHealthPotion" class="px-3 py-1 bg-red-500 hover:bg-red-600 text-white rounded text-sm font-medium transition-colors">
                                        <i class="fas fa-heart mr-1"></i>Health
                                    </button>
                                </div>
                            </div>

                            <div id="equipmentList" class="space-y-2">
                                <!-- Equipment items will be listed here -->
                            </div>
                        </div>

                        <!-- Notes -->
                        <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                            <h3 class="font-semibold mb-3">Notes</h3>
                            <textarea id="characterNotes" placeholder="Character notes, backstory, abilities..." class="w-full h-32 px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent resize-none"></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Equipment Modal -->
    <div id="equipmentModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
            <h3 class="text-lg font-semibold mb-4">Add Equipment</h3>
            <form id="equipmentForm">
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">Item Name</label>
                    <input type="text" id="equipmentName" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent" required>
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">Quantity</label>
                    <input type="number" id="equipmentQuantity" value="1" min="1" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent">
                </div>
                <div class="flex justify-end space-x-3">
                    <button type="button" id="cancelEquipment" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-primary text-white hover:bg-primary-dark rounded">Add Item</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Temp Points Modal -->
    <div id="tempPointsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h3 id="tempPointsTitle" class="text-lg font-semibold">Manage Temp Points</h3>
                <button type="button" id="cancelTempPoints" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="mb-4">
                <div class="text-sm text-gray-600 dark:text-gray-400 mb-2">
                    Current Points: <span id="currentResourcePoints">0</span>
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                    Permanent: <span id="permanentResourcePoints">0</span> | 
                    Temporary: <span id="temporaryResourcePoints">0</span>
                </div>
                <input type="number" id="tempPointsAmount" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Number of points" min="1" max="12">
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" id="addTempPoints" class="px-4 py-2 bg-green-500 text-white hover:bg-green-600 rounded">Add Temp</button>
                <button type="button" id="removeTempPoints" class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded">Remove</button>
            </div>
        </div>
    </div>

    <!-- Temp Threshold Modal -->
    <div id="tempThresholdModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold">Add TEMP Threshold</h3>
                <button type="button" id="cancelTempThreshold" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium mb-2">Lower</label>
                    <input type="number" id="tempThresholdLower" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="0" min="0">
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Upper</label>
                    <input type="number" id="tempThresholdUpper" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="0" min="0">
                </div>
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" id="resetTempThreshold" class="px-4 py-2 bg-gray-500 text-white hover:bg-gray-600 rounded">Reset</button>
                <button type="button" id="confirmTempThreshold" class="px-4 py-2 bg-primary text-white hover:bg-primary-dark rounded">OK</button>
            </div>
        </div>
    </div>

    <!-- Enhanced Armor Slots Modal -->
    <div id="armorSlotsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold">Manage Armor Slots</h3>
                <button type="button" id="cancelArmorSlots" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="mb-4">
                <div class="text-sm text-gray-600 dark:text-gray-400 mb-2">
                    Current Armor Slots: <span id="currentArmorSlots">0</span>
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                    Permanent: <span id="permanentArmorSlots">0</span> | 
                    Temporary: <span id="temporaryArmorSlots">0</span>
                </div>
                <input type="number" id="armorSlotsAmount" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Number of slots" min="1" max="12">
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" id="addArmorSlots" class="px-4 py-2 bg-green-500 text-white hover:bg-green-600 rounded">Add Temp</button>
                <button type="button" id="removeArmorSlots" class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded">Remove</button>
            </div>
        </div>
    </div>

    <!-- Evasion Modal -->
    <div id="evasionModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold">Manage Evasion</h3>
                <button type="button" id="cancelEvasion" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            <div class="mb-4">
                <div class="text-sm text-gray-600 dark:text-gray-400 mb-2">
                    Current Evasion: <span id="currentEvasion">0</span>
                </div>
                <div class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                    Base: <span id="baseEvasion">0</span> | 
                    Temporary: <span id="temporaryEvasion">0</span> | 
                    Armor: <span id="armorEvasion">0</span>
                </div>
                <input type="number" id="evasionAmount" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Evasion value" min="1">
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" id="resetTempEvasion" class="px-4 py-2 bg-gray-500 text-white hover:bg-gray-600 rounded">Reset Temp</button>
                <button type="button" id="addTempEvasion" class="px-4 py-2 bg-green-500 text-white hover:bg-green-600 rounded">Add Temp</button>
                <button type="button" id="adjustBaseEvasion" class="px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded">Adjust Base</button>
            </div>
        </div>
    </div>

    <!-- New Ability Score Selection Modal -->
    <div id="abilityScoreModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
            <h3 class="text-lg font-semibold mb-4" id="abilityScoreModalTitle">Allocate Ability Score Points</h3>
            
            <!-- Points Counter -->
            <div class="grid grid-cols-2 gap-4 mb-6">
                <div class="points-counter">
                    <div class="text-sm">Positive Points Remaining</div>
                    <div class="text-xl font-bold" id="positivePointsRemaining">0</div>
                </div>
                <div class="points-counter">
                    <div class="text-sm">Negative Points Remaining</div>
                    <div class="text-xl font-bold" id="negativePointsRemaining">0</div>
                </div>
            </div>
            
            <!-- Positive Points Section -->
            <div id="positivePointsSection" class="mb-6">
                <h4 class="text-md font-semibold mb-3 text-green-600 dark:text-green-400">Increase Ability Scores</h4>
                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div class="ability-checkbox" data-type="positive" data-ability="str">
                        <input type="checkbox" class="mr-2">
                        <span>Strength (STR)</span>
                    </div>
                    <div class="ability-checkbox" data-type="positive" data-ability="dex">
                        <input type="checkbox" class="mr-2">
                        <span>Dexterity (DEX)</span>
                    </div>
                    <div class="ability-checkbox" data-type="positive" data-ability="con">
                        <input type="checkbox" class="mr-2">
                        <span>Constitution (CON)</span>
                    </div>
                    <div class="ability-checkbox" data-type="positive" data-ability="int">
                        <input type="checkbox" class="mr-2">
                        <span>Intelligence (INT)</span>
                    </div>
                    <div class="ability-checkbox" data-type="positive" data-ability="wis">
                        <input type="checkbox" class="mr-2">
                        <span>Wisdom (WIS)</span>
                    </div>
                    <div class="ability-checkbox" data-type="positive" data-ability="cha">
                        <input type="checkbox" class="mr-2">
                        <span>Charisma (CHA)</span>
                    </div>
                </div>
                
                <!-- Multi-point options for positive points -->
                <div id="positiveMultiOptions" class="hidden">
                    <div class="ability-checkbox" data-type="positive-multi" data-value="2">
                        <input type="checkbox" class="mr-2">
                        <span>Apply all positive points to one ability score</span>
                    </div>
                </div>
            </div>

            <!-- Negative Points Section -->
            <div id="negativePointsSection" class="mb-6 hidden">
                <h4 class="text-md font-semibold mb-3 text-red-600 dark:text-red-400">Decrease Ability Scores</h4>
                <div class="grid grid-cols-2 gap-3 mb-3">
                    <div class="ability-checkbox" data-type="negative" data-ability="str">
                        <input type="checkbox" class="mr-2">
                        <span>Strength (STR)</span>
                    </div>
                    <div class="ability-checkbox" data-type="negative" data-ability="dex">
                        <input type="checkbox" class="mr-2">
                        <span>Dexterity (DEX)</span>
                    </div>
                    <div class="ability-checkbox" data-type="negative" data-ability="con">
                        <input type="checkbox" class="mr-2">
                        <span>Constitution (CON)</span>
                    </div>
                    <div class="ability-checkbox" data-type="negative" data-ability="int">
                        <input type="checkbox" class="mr-2">
                        <span>Intelligence (INT)</span>
                    </div>
                    <div class="ability-checkbox" data-type="negative" data-ability="wis">
                        <input type="checkbox" class="mr-2">
                        <span>Wisdom (WIS)</span>
                    </div>
                    <div class="ability-checkbox" data-type="negative" data-ability="cha">
                        <input type="checkbox" class="mr-2">
                        <span>Charisma (CHA)</span>
                    </div>
                </div>
                
                <!-- Multi-point options for negative points -->
                <div id="negativeMultiOptions" class="hidden">
                    <div class="ability-checkbox" data-type="negative-multi" data-value="-2">
                        <input type="checkbox" class="mr-2">
                        <span>Apply all negative points to one ability score</span>
                    </div>
                </div>
            </div>
            
            <div class="flex justify-end space-x-3">
                <button type="button" id="cancelAbilityScoreNew" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                <button type="button" id="confirmAbilityScoreNew" class="px-4 py-2 bg-primary text-white hover:bg-primary-dark rounded">Apply Changes</button>
            </div>
        </div>
    </div>

    <!-- Weapon Selection Modal -->
    <div id="weaponModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-3xl w-full mx-4 max-h-[80vh] overflow-y-auto">
            <h3 class="text-lg font-semibold mb-4" id="weaponModalTitle">Select Primary Weapon</h3>
            <div id="weaponList" class="space-y-3 mb-6 max-h-96 overflow-y-auto">
                <!-- Weapons will be populated here -->
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" id="cancelWeapon" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                <button type="button" id="confirmWeapon" class="px-4 py-2 bg-primary text-white hover:bg-primary-dark rounded">Add Weapon</button>
            </div>
        </div>
    </div>

    <!-- Weapon Removal Confirmation Modal -->
    <div id="weaponRemovalModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
            <h3 class="text-lg font-semibold mb-4" id="weaponRemovalTitle">Remove Primary Weapon</h3>
            <p class="text-gray-700 dark:text-gray-300 mb-4">Are you sure you want to remove this weapon? All weapon bonuses will be removed from your character.</p>
            <div class="flex justify-end space-x-3">
                <button type="button" id="cancelWeaponRemoval" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                <button type="button" id="confirmWeaponRemoval" class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded">Remove</button>
            </div>
        </div>
    </div>

    <!-- Character Deletion Confirmation Modal -->
    <div id="characterDeletionModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
            <h3 class="text-lg font-semibold mb-4 text-red-600 dark:text-red-400">
                <i class="fas fa-exclamation-triangle mr-2"></i>Delete Character
            </h3>
            <p class="text-gray-700 dark:text-gray-300 mb-4">
                Do you want to delete <strong id="deleteCharacterName">[Character Name]</strong>?
            </p>
            <p class="text-sm text-gray-600 dark:text-gray-400 mb-6">
                This action cannot be undone. The character and all their data will be permanently removed.
            </p>
            
            <!-- Confirmation Checkbox -->
            <div class="mb-6">
                <label class="flex items-center cursor-pointer">
                    <input type="checkbox" id="deleteConfirmationCheckbox" class="mr-3 rounded">
                    <span class="text-sm text-gray-700 dark:text-gray-300">I understand this action cannot be undone</span>
                </label>
            </div>
            
            <div class="flex justify-end space-x-3">
                <button type="button" id="cancelCharacterDeletion" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                <button type="button" id="confirmCharacterDeletion" class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded opacity-50 cursor-not-allowed" disabled>Delete Character</button>
            </div>
        </div>
    </div>

    <!-- Level Up Modal -->
    <div id="levelUpModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
            <h3 class="text-lg font-semibold mb-4" id="levelUpTitle">Level Up!</h3>
            
            <!-- Automatic Bonuses -->
            <div class="mb-6 p-4 bg-green-50 dark:bg-green-900 rounded-lg">
                <div class="text-green-800 dark:text-green-200 font-semibold mb-2" id="levelUpThresholdBonus">
                    <!-- Character name and automatic bonuses will be inserted here -->
                </div>
                <div class="text-green-800 dark:text-green-200 font-semibold" id="levelUpSpellBonus" style="display: none;">
                    <!-- Spell caster bonus will be inserted here -->
                </div>
            </div>
            
            <!-- Selection Counter -->
            <div class="mb-4 p-3 bg-blue-50 dark:bg-blue-900 rounded-lg">
                <div class="text-blue-800 dark:text-blue-200 text-sm">
                    <span id="levelUpSelectionCount">0</span> of 2 options selected
                </div>
            </div>
            
            <!-- Level Up Options -->
            <div class="space-y-3 mb-6">
                <h4 class="font-semibold text-md">Select 2 Options:</h4>
                
                <!-- Resource Options -->
                <div class="grid grid-cols-2 gap-3">
                    <div class="level-up-option" data-type="resource" data-resource="hp" data-value="1">
                        <input type="checkbox" class="mr-2">
                        <span>+1 Hit Point</span>
                    </div>
                    <div class="level-up-option" data-type="resource" data-resource="stress" data-value="1">
                        <input type="checkbox" class="mr-2">
                        <span>+1 Stress</span>
                    </div>
                    <div class="level-up-option" data-type="resource" data-resource="class" data-value="1">
                        <input type="checkbox" class="mr-2">
                        <span>+1 Class</span>
                    </div>
                    <div class="level-up-option" data-type="resource" data-resource="spell" data-value="1">
                        <input type="checkbox" class="mr-2">
                        <span>+1 Spell</span>
                    </div>
                    <div class="level-up-option" data-type="resource" data-resource="armor" data-value="1">
                        <input type="checkbox" class="mr-2">
                        <span>+1 Armor</span>
                    </div>
                    <div class="level-up-option" data-type="threshold" data-lower="1" data-upper="1">
                        <input type="checkbox" class="mr-2">
                        <span>+1/+1 Threshold</span>
                    </div>
                </div>
                
                <!-- Ability Score Options -->
                <div class="mt-4">
                    <h5 class="font-medium text-sm mb-2">Ability Scores (each counts as 1 option):</h5>
                    <div class="grid grid-cols-3 gap-2">
                        <div class="level-up-option" data-type="ability" data-ability="str" data-value="1" id="levelUpStr">
                            <input type="checkbox" class="mr-2">
                            <span>+1 STR</span>
                        </div>
                        <div class="level-up-option" data-type="ability" data-ability="dex" data-value="1" id="levelUpDex">
                            <input type="checkbox" class="mr-2">
                            <span>+1 DEX</span>
                        </div>
                        <div class="level-up-option" data-type="ability" data-ability="con" data-value="1" id="levelUpCon">
                            <input type="checkbox" class="mr-2">
                            <span>+1 CON</span>
                        </div>
                        <div class="level-up-option" data-type="ability" data-ability="int" data-value="1" id="levelUpInt">
                            <input type="checkbox" class="mr-2">
                            <span>+1 INT</span>
                        </div>
                        <div class="level-up-option" data-type="ability" data-ability="wis" data-value="1" id="levelUpWis">
                            <input type="checkbox" class="mr-2">
                            <span>+1 WIS</span>
                        </div>
                        <div class="level-up-option" data-type="ability" data-ability="cha" data-value="1" id="levelUpCha">
                            <input type="checkbox" class="mr-2">
                            <span>+1 CHA</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="flex justify-end space-x-3">
                <button type="button" id="cancelLevelUp" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                <button type="button" id="confirmLevelUp" class="px-4 py-2 bg-green-500 text-white hover:bg-green-600 rounded">Confirm Level Up</button>
            </div>
        </div>
    </div>

    <!-- Rest Modal -->
    <div id="restModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
            <h3 class="text-lg font-semibold mb-4">Rest</h3>
            
            <!-- Rest Type Buttons -->
            <div class="grid grid-cols-2 gap-3 mb-6">
                <button id="shortRestBtn" class="px-4 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-medium transition-colors">
                    <i class="fas fa-moon mr-2"></i>Short Rest
                </button>
                <button id="longRestBtn" class="px-4 py-3 bg-purple-500 hover:bg-purple-600 text-white rounded-lg font-medium transition-colors">
                    <i class="fas fa-bed mr-2"></i>Long Rest
                </button>
            </div>
            
            <!-- Resource Selection -->
            <div class="mb-6">
                <h4 class="font-medium mb-3">Select Resources to Restore (Max 2):</h4>
                <div class="space-y-2">
                    <label class="rest-resource-option flex items-center p-2 border border-gray-300 dark:border-gray-600 rounded cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700">
                        <input type="checkbox" class="mr-3" data-resource="armorSlots">
                        <span>Armor Slots</span>
                    </label>
                    <label class="rest-resource-option flex items-center p-2 border border-gray-300 dark:border-gray-600 rounded cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700">
                        <input type="checkbox" class="mr-3" data-resource="hp">
                        <span>HP</span>
                    </label>
                    <label class="rest-resource-option flex items-center p-2 border border-gray-300 dark:border-gray-600 rounded cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700">
                        <input type="checkbox" class="mr-3" data-resource="stress">
                        <span>Stress</span>
                    </label>
                    <label class="rest-resource-option flex items-center p-2 border border-gray-300 dark:border-gray-600 rounded cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700">
                        <input type="checkbox" class="mr-3" data-resource="class">
                        <span>Class</span>
                    </label>
                    <label class="rest-resource-option flex items-center p-2 border border-gray-300 dark:border-gray-600 rounded cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700">
                        <input type="checkbox" class="mr-3" data-resource="spell">
                        <span>Spell</span>
                    </label>
                </div>
                <div class="mt-2 text-sm text-gray-600 dark:text-gray-400">
                    Selected: <span id="restSelectionCount">0</span> / 2
                </div>
            </div>
            
            <div class="flex justify-end space-x-3">
                <button type="button" id="cancelRest" class="px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Primary Weapon database
        const primaryWeaponDatabase = [
            {
                name: "Battleaxe",
                trait: "STR",
                range: "Melee",
                damage: "d6/d12",
                feature: "1H/2H, B/S, -1 DEX",
                bonuses: { armor: 1, dex: -1}
            },
            {
                name: "Broad Sword",
                trait: "STR/DEX",
                range: "Melee",
                damage: "d8",
                feature: "1H, B/S",
                bonuses: {}
            },
            {
                name: "Crossbow",
                trait: "DEX",
                range: "Far",
                damage: "d6",
                feature: "1H/2H, P",
                bonuses: {}
            },
            {
                name: "Cutlass",
                trait: "DEX",
                range: "Melee",
                damage: "d8",
                feature: "1H, S",
                bonuses: {}
            },
            {
                name: "Dagger",
                trait: "DEX/INT",
                range: "Melee",
                damage: "d4",
                feature: "1H, P",
                bonuses: {}
            },
            {
                name: "Guantlets",
                trait: "STR/DEX/INT",
                range: "Melee",
                damage: "d4",
                feature: "2H, B, +1 Evasion",
                bonuses: { evasion: 1 }
            },
            {
                name: "Great Staff",
                trait: "STR/INT",
                range: "Melee",
                damage: "d10",
                feature: "2H, B, -1 DEX",
                bonuses: { dex: -1 }
            },
            {
                name: "Greatsword",
                trait: "STR",
                range: "Melee",
                damage: "d10",
                feature: "2H, B/S, -1 DEX",
                bonuses: { dex: -1 }
            },
            {
                name: "Halberd",
                trait: "STR",
                range: "Close",
                damage: "d10",
                feature: "2H, -1 DEX",
                bonuses: { dex: -1 }
            },
            {
                name: "Hallowed Axe",
                trait: "DEX/WIS",
                range: "Melee",
                damage: "d8/d10",
                feature: "1H/2H, B/S",
                bonuses: {}
            },
            {
                name: "Hand Axe",
                trait: "STR/DEX",
                range: "Melee",
                damage: "d6",
                feature: "1H, B/S",
                bonuses: {}
            },
            {
                name: "Long Bow",
                trait: "DEX",
                range: "Very Far",
                damage: "d6",
                feature: "2H, P, -1 Evasion",
                bonuses: { evasion: -1 }
            },
            {
                name: "Long Sword",
                trait: "DEX",
                range: "Melee",
                damage: "d8",
                feature: "2H, S",
                bonuses: {}
            },
            {
                name: "Mace",
                trait: "STR/WIS",
                range: "Melee",
                damage: "d8",
                feature: "1H, B",
                bonuses: {}
            },
            {
                name: "Rapier",
                trait: "DEX/CHA",
                range: "Melee",
                damage: "d6",
                feature: "1H, P",
                bonuses: {}
            },
            {
                name: "Returning Blade",
                trait: "INT/CHA",
                range: "Close",
                damage: "d6",
                feature: "1H, S",
                bonuses: {}
            },
            {
                name: "Ritual Blade",
                trait: "STR/WIS",
                range: "Melee",
                damage: "d6/d8",
                feature: "1H/2H, S",
                bonuses: {}
            },
                {
                name: "Ritual Hammer",
                trait: "STR/WIS",
                range: "Melee",
                damage: "d6/d8",
                feature: "1H/2H, S",
                bonuses: {}
            },
                {
                name: "Rune Stones",
                trait: "DEX/INT",
                range: "Close",
                damage: "d6",
                feature: "1H, F, +1 Evasion",
                bonuses: { evasion: 1 }
            },
                {
                name: "Runic Blade",
                trait: "DEX",
                range: "Melee",
                damage: "d6/d8",
                feature: "1H/2H, S",
                bonuses: {}
            },
                {
                name: "Scepter",
                trait: "INT/WIS/CHA",
                range: "Far",
                damage: "d6",
                feature: "1H, B",
                bonuses: {}
            },
                {
                name: "Shortbow",
                trait: "DEX",
                range: "FAR",
                damage: "d6",
                feature: "2H, P",
                bonuses: {}
            },
                {
                name: "Short Sword",
                trait: "DEX",
                range: "Melee",
                damage: "d6",
                feature: "1H, P",
                bonuses: {}
            },
                {
                name: "Sling",
                trait: "DEX",
                range: "Close",
                damage: "d6",
                feature: "1H, B",
                bonuses: {}
            },
                {
                name: "Spear",
                trait: "STR/WIS",
                range: "Close/Far",
                damage: "d6",
                feature: "2H, P",
                bonuses: {}
            },
                {
                name: "Quarterstaff",
                trait: "STR/DEX",
                range: "Close",
                damage: "d6",
                feature: "2H, B",
                bonuses: {}
            },
                {
                name: "Warhammer",
                trait: "STR/WIS",
                range: "Melee",
                damage: "d12",
                feature: "2H, B, -1 DEX",
                bonuses: { dex: -1 }
            },
        ];

        // Secondary Weapon database (different from primary)
        const secondaryWeaponDatabase = [
            {
                name: "Dagger",
                trait: "DEX/INT",
                range: "Melee",
                damage: "d4",
                feature: "1H, P",
                bonuses: { thresholdLower: 1 }
            },
            {
                name: "Hand Axe",
                trait: "STR/DEX",
                range: "Melee",
                damage: "d6",
                feature: "1H, B/S",
                bonuses: {}
            },
            {
                name: "Hand Crossbow",
                trait: "DEX",
                range: "Far",
                damage: "d6",
                feature: "1H, P",
                bonuses: {}
            },
            {
                name: "Mace",
                trait: "STR/WIS",
                range: "Melee",
                damage: "d8",
                feature: "1H, B",
                bonuses: {}
            },
            {
                name: "Short Sword",
                trait: "DEX",
                range: "Melee",
                damage: "d6",
                feature: "1H, P",
                bonuses: {}
            },
            {
                name: "Shield",
                trait: "STR",
                range: "Melee",
                damage: "d4",
                feature: "1H, +1 Armor, Threshold 2|2",
                bonuses: { armor: 1, thresholdLower: 2, thresholdUpper: 2 }
            },
            {
                name: "Tower Shield",
                trait: "STR",
                range: "Melee",
                damage: "d4",
                feature: "1H, +3 Armor, Threshold 5|5, -2 Evasion",
                bonuses: { armor: 3, thresholdLower: 5, thresholdUpper: 5, evasion: -2 }
            },
        ];

        // Armor database
        const armorDatabase = [
            {
                name: "No Armor",
                thresholdLower: 3,
                thresholdUpper: 5,
                armor: 0,
                feature: "+2 Evasion",
                bonuses: { thresholdLower: 3, thresholdUpper: 5, evasion: 2 }
            },
            {
                name: "Padded",
                thresholdLower: 5,
                thresholdUpper: 11,
                armor: 2,
                feature: "+1 Evasion",
                bonuses: { thresholdLower: 5, thresholdUpper: 11, armor: 2, evasion: 1 }
            },
            {
                name: "Leather",
                thresholdLower: 6,
                thresholdUpper: 13,
                armor: 3,
                feature: "",
                bonuses: { thresholdLower: 6, thresholdUpper: 13, armor: 3 }
            },
            {
                name: "Chain",
                thresholdLower: 7,
                thresholdUpper: 15,
                armor: 4,
                feature: "-1 Evasion",
                bonuses: { thresholdLower: 7, thresholdUpper: 15, armor: 4, evasion: -1 }
            },
            {
                name: "Plate",
                thresholdLower: 8,
                thresholdUpper: 17,
                armor: 5,
                feature: "-2 Evasion, -1 DEX",
                bonuses: { thresholdLower: 8, thresholdUpper: 17, armor: 5, evasion: -2, dex: -1 }
            },
        ];

        // Global weapon state
        let selectedWeapon = null;
        let currentWeaponType = null; // 'primary', 'secondary', or 'armor'
        let selectedArmor = null;

        // Rest system state
        let restSelectedResources = [];
        let restType = null; // 'short' or 'long'

        // Race data for bonuses and proficiencies
        const raceData = {
            'Assaimar': {
                bonuses: [
                    { type: 'hp', value: 1, label: 'HP +1' }
                ],
                proficiencies: ['dex', 'con', 'int', 'wis'],
                abilityScores: [
                    { value: 1, label: 'Stats +1' }
                ],
                evasion: 10
            },
            'Dragonborn': {
                bonuses: [
                    { type: 'stress', value: 1, label: 'Stress +1' },
                    { type: 'threshold', lowerValue: 1, upperValue: +1, label: 'Threshold +1/+1' }
                ],
                proficiencies: ['str', 'con', 'int', 'wis'],
                abilityScores: [
                    { value: 2, label: 'Stats +1' },
                    { value: -1, label: 'Stats -1' }
                ],
                evasion: 9
            },
            'Dwarf': {
                bonuses: [
                    { type: 'threshold', lowerValue: 1, upperValue: 1, label: 'Threshold +1/+1' }
                ],
                proficiencies: ['str', 'con', 'int', 'wis'],
                abilityScores: [
                    { value: 1, label: 'Stats +1' }
                ],
                evasion: 9
            },
            'Elf': {
                bonuses: [
                    { type: 'class', value: 1, label: 'Class +1' },
                    { type: 'spell', value: 1, label: 'Spell +1' }
                ],
                proficiencies: ['dex', 'int', 'wis', 'cha'],
                abilityScores: [
                    { value: 2, label: 'Stats +2' },
                    { value: -1, label: 'Stats -1' }
                ],
                evasion: 11
            },
            'Gnome': {
                bonuses: [
                    { type: 'class', value: 1, label: 'Class +1' },
                    { type: 'spell', value: 2, label: 'Spell +2' }
                ],
                proficiencies: ['dex', 'int', 'wis', 'cha'],
                abilityScores: [
                    { value: 1, label: 'Stats +1' }
                ],
                evasion: 11
            },
            'Halfling': {
                bonuses: [
                    { type: 'class', value: 2, label: 'Class +2' },
                    { type: 'spell', value: 2, label: 'Spell +2' }
                ],
                proficiencies: ['dex', 'int', 'wis', 'cha'],
                abilityScores: [
                    { value: 1, label: 'Stats +1' }
                ],
                evasion: 11
            },
            'Human': {
                bonuses: [
                    { type: 'stress', value: 1, label: 'Stress +1' },
                    { type: 'class', value: 1, label: 'Class +1' }
                ],
                proficiencies: ['str', 'dex', 'con', 'int', 'wis', 'cha'],
                abilityScores: [
                    { value: 2, label: 'Stats +2' }
                ],
                evasion: 10
            },
            'Orc': {
                bonuses: [
                    { type: 'hp', value: 2, label: 'HP +2' },
                    { type: 'threshold', lowerValue: 2, upperValue: 2, label: 'Threshold +2/+2' }
                ],
                proficiencies: ['str', 'dex', 'con', 'cha'],
                abilityScores: [
                    { value: 1, label: 'Stats +1' },
                    { value: -1, label: 'Stats -1' }
                ],
                evasion: 9
            },
            'Tiefling': {
                bonuses: [
                    { type: 'stress', value: 2, label: 'Stress +2' },
                    { type: 'spell', value: 1, label: 'Spell +1' }
                ],
                proficiencies: ['str', 'con', 'int', 'cha'],
                abilityScores: [
                    { value: 1, label: 'Stats +1' },
                    { value: 1, label: 'Stats +1' }
                ],
                evasion: 10
            }
        };

        // Global state
        let characters = [];
        let currentCharacter = null;
        
        // Ranger Companion data
        const companionTypes = {
            'Bear': {
                hp: 2,
                stress: 2,
                evasion: 10,
                mod: 2,
                damage: 'd6',
                thresholdLower: 5,
                thresholdUpper: 10
            },
            'Great Cat': {
                hp: 3,
                stress: 2,
                evasion: 10,
                mod: 3,
                damage: 'd8',
                thresholdLower: 5,
                thresholdUpper: 10
            },
            'Wolf': {
                hp: 2,
                stress: 3,
                evasion: 11,
                mod: 2,
                damage: 'd6',
                thresholdLower: 4,
                thresholdUpper: 8
            },
            'Hawk': {
                hp: 1,
                stress: 2,
                evasion: 13,
                mod: 3,
                damage: 'd4',
                thresholdLower: 3,
                thresholdUpper: 6
            }
        };
        
        // Ability score modifier system
        const availableModifiers = [2, 1, 1, 0, 0, -1];
        let selectedModifiers = { str: null, dex: null, con: null, int: null, wis: null, cha: null };
        let usedModifiers = [];
        
        // Proficiency system
        let proficiencies = { str: false, dex: false, con: false, int: false, wis: false, cha: false };
        
        // Race selection tracking
        let selectedRaceBonuses = [];
        let selectedRaceProficiencies = [];
        let selectedAbilityScores = [];
        let raceBonusValues = {
            hp: 0,
            stress: 0,
            class: 0,
            spell: 0,
            evasion: 0,
            thresholdLower: 0,
            thresholdUpper: 0
        };
        let raceAbilityBonuses = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };

        // New ability score modal state
        let currentRaceAbilityScores = [];
        let abilityScoreAllocations = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };

        // Level Up state
        let levelUpSelectedOptions = [];
        let levelUpSelectionsCount = 0;

        // Class data for resources and thresholds
        const classData = {
            'Barbarian': {
                hp: 3,
                stress: 2,
                class: 2,
                spell: 0,
                thresholdLower: 1,
                thresholdUpper: 2,
            },
            'Bard': {
                hp: 1,
                stress: 1,
                class: 3,
                spell: 2,
                thresholdLower: 1,
                thresholdUpper: 1,
            },
            'Cleric': {
                hp: 2,
                stress: 3,
                class: 2,
                spell: 2,
                thresholdLower: 1,
                thresholdUpper: 1,
            },
            'Druid': {
                hp: 2,
                stress: 3,
                class: 2,
                spell: 1,
                thresholdLower: 1,
                thresholdUpper: 0,
            },
            'Fighter': {
                hp: 3,
                stress: 3,
                class: 2,
                spell: 0,
                thresholdLower: 1,
                thresholdUpper: 2,
            },
            'Monk': {
                hp: 2,
                stress: 3,
                class: 1,
                spell: 0,
                thresholdLower: 0,
                thresholdUpper: 1,
            },
            'Paladin': {
                hp: 3,
                stress: 3,
                class: 1,
                spell: 0,
                thresholdLower: 2,
                thresholdUpper: 1,
            },
            'Ranger': {
                hp: 2,
                stress: 3,
                class: 3,
                spell: 0,
                thresholdLower: 1,
                thresholdUpper: 1,
            },
            'Rogue': {
                hp: 2,
                stress: 3,
                class: 2,
                spell: 0,
                thresholdLower: 0,
                thresholdUpper: 1,
            },
            'Sorcerer': {
                hp: 1,
                stress: 2,
                class: 3,
                spell: 2,
                thresholdLower: 0,
                thresholdUpper: 1,
            },
            'Warlock': {
                hp: 2,
                stress: 2,
                class: 2,
                spell: 1,
                thresholdLower: 1,
                thresholdUpper: 1,
            },
            'Wizard': {
                hp: 1,
                stress: 2,
                class: 2,
                spell: 3,
                thresholdLower: 0,
                thresholdUpper: 1,
            }
        };

        // Default skills list
        const defaultSkills = [
            { name: 'Athletics', ability: 'str' },
            { name: 'Acrobatics', ability: 'dex' },
            { name: 'Stealth', ability: 'dex' },
            { name: 'Investigation', ability: 'int' },
            { name: 'History', ability: 'int' },
            { name: 'Insight', ability: 'wis' },
            { name: 'Perception', ability: 'wis' },
            { name: 'Persuasion', ability: 'cha' },
            { name: 'Deception', ability: 'cha' }
        ];

        // New function to handle threshold damage buttons
        function applyDamage(amount) {
            if (!currentCharacter) return;
            
            // Ensure resources are initialized
            if (!currentCharacter.resources) {
                currentCharacter.resources = {
                    hp: { max: 0, used: [], temp: 0 },
                    stress: { max: 0, used: [], temp: 0 },
                    class: { max: 0, used: [], temp: 0 },
                    spell: { max: 0, used: [], temp: 0 }
                };
            }
            
            const hpResource = currentCharacter.resources.hp;
            const totalHp = hpResource.max + (hpResource.temp || 0);
            const currentUsed = hpResource.used.length;
            
            // Check if we have enough HP remaining
            if (currentUsed + amount > totalHp) {
                showCustomDialog('Insufficient HP', `Cannot apply ${amount} damage. Only ${totalHp - currentUsed} HP remaining.`);
                return;
            }
            
            // Apply damage by marking HP boxes as used
            for (let i = 0; i < amount; i++) {
                // Find the first unused HP box and mark it as used
                for (let j = 0; j < totalHp; j++) {
                    if (!hpResource.used.includes(j)) {
                        hpResource.used.push(j);
                        break;
                    }
                }
            }
            
            // Refresh the HP display
            populateSheetResourceBoxes(currentCharacter);
            saveCharacters();
        }

        // Rest System Functions
        function showRestModal() {
            if (!currentCharacter) return;
            
            // Reset rest state
            restSelectedResources = [];
            restType = null;
            updateRestSelectionCount();
            
            // Clear all checkboxes
            document.querySelectorAll('#restModal input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
                checkbox.closest('.rest-resource-option').classList.remove('selected');
            });
            
            document.getElementById('restModal').classList.remove('hidden');
        }

        function updateRestSelectionCount() {
            document.getElementById('restSelectionCount').textContent = restSelectedResources.length;
        }

        function handleRestResourceSelection(checkbox) {
            const resource = checkbox.dataset.resource;
            const option = checkbox.closest('.rest-resource-option');
            
            if (checkbox.checked) {
                if (restSelectedResources.length >= 2) {
                    checkbox.checked = false;
                    showCustomDialog('Selection Limit', 'You can only select up to 2 resources to restore.');
                    return;
                }
                restSelectedResources.push(resource);
                option.classList.add('selected');
            } else {
                restSelectedResources = restSelectedResources.filter(r => r !== resource);
                option.classList.remove('selected');
            }
            
            updateRestSelectionCount();
        }

        function executeShortRest() {
            if (!currentCharacter || restSelectedResources.length === 0) {
                showCustomDialog('No Selection', 'Please select at least one resource to restore.');
                return;
            }
            
            // Determine how many points to restore based on level
            const level = currentCharacter.level || 1;
            let pointsToRestore;
            
            if (level >= 1 && level <= 5) {
                pointsToRestore = 2;
            } else if (level >= 6 && level <= 8) {
                pointsToRestore = 3;
            } else if (level >= 9 && level <= 10) {
                pointsToRestore = 4;
            }
            
            // Process each selected resource
            restSelectedResources.forEach(resource => {
                if (resource === 'armorSlots') {
                    restoreArmorSlots(pointsToRestore);
                } else {
                    restoreResourceBoxes(resource, pointsToRestore);
                }
            });
            
            // Save and refresh
            saveCharacters();
            populateCharacterSheet(currentCharacter);
            updateCharacterDisplay(); // Update character cards
            
            // Close modal
            document.getElementById('restModal').classList.add('hidden');
            
            showCustomDialog('Short Rest Complete', `${currentCharacter.name} has rested and restored ${pointsToRestore} points for the selected resources.`);
        }

        function executeLongRest() {
            if (!currentCharacter || restSelectedResources.length === 0) {
                showCustomDialog('No Selection', 'Please select at least one resource to restore.');
                return;
            }
            
            // Process each selected resource - restore ALL points
            restSelectedResources.forEach(resource => {
                if (resource === 'armorSlots') {
                    restoreAllArmorSlots();
                } else {
                    restoreAllResourceBoxes(resource);
                }
            });
            
            // ALWAYS REMOVE ALL TEMPORARY BONUSES DURING LONG REST (regardless of selection)
            
            // Remove ALL temporary resource points from ALL resources and clean up used boxes
            if (currentCharacter.resources) {
                ['hp', 'stress', 'class', 'spell'].forEach(resourceType => {
                    if (currentCharacter.resources[resourceType]) {
                        const resource = currentCharacter.resources[resourceType];
                        // Remove temporary points
                        resource.temp = 0;
                        // Clean up any used boxes that are now beyond the permanent maximum
                        resource.used = resource.used.filter(index => index < resource.max);
                    }
                });
            }
            
            // Remove temporary armor slots
            if (currentCharacter.armorSlots) {
                currentCharacter.armorSlots.temporary = 0;
                currentCharacter.armorSlots.total = currentCharacter.armorSlots.permanent;
                // Remove filled states that are now beyond the total
                currentCharacter.armorSlots.filled = currentCharacter.armorSlots.filled.filter(index => index < currentCharacter.armorSlots.total);
            }
            
            // Remove all temporary threshold values
            if (currentCharacter.tempThreshold) {
                currentCharacter.tempThreshold = { lower: 0, upper: 0 };
            }
            
            // Remove all temporary evasion values (for both normal and unarmored defense modes)
            if (currentCharacter.normalEvasionData) {
                currentCharacter.normalEvasionData.temporary = 0;
            }
            if (currentCharacter.unarmoredDefenseEvasionData) {
                currentCharacter.unarmoredDefenseEvasionData.temporary = 0;
            }
            // Also handle legacy evasionData structure
            if (currentCharacter.evasionData) {
                currentCharacter.evasionData.temporary = 0;
            }
            
            // Disable Mage Armor during long rest
            if (currentCharacter.mageArmorActive) {
                removeMageArmorBonuses();
                currentCharacter.mageArmorActive = false;
                
                // Update the checkbox in the UI
                const mageArmorCheckbox = document.getElementById('mageArmorToggle');
                if (mageArmorCheckbox) {
                    mageArmorCheckbox.checked = false;
                }
            }
            
            // Recalculate current evasion based on active mode
            updateCharacterEvasion();
            
            // Save and refresh
            saveCharacters();
            populateCharacterSheet(currentCharacter);
            updateCharacterDisplay(); // Update character cards
            
            // Close modal
            document.getElementById('restModal').classList.add('hidden');
            
            showCustomDialog('Long Rest Complete', `${currentCharacter.name} has taken a long rest and fully restored the selected resources. All temporary bonuses have been removed.`);
        }

        function restoreResourceBoxes(resourceType, pointsToRestore) {
            if (!currentCharacter.resources || !currentCharacter.resources[resourceType]) return;
            
            const resource = currentCharacter.resources[resourceType];
            const usedIndices = [...resource.used].sort((a, b) => b - a); // Sort descending to remove from highest indices first
            
            let pointsRestored = 0;
            
            // Remove from the highest used indices first (temporary boxes first, then permanent)
            for (let i = 0; i < usedIndices.length && pointsRestored < pointsToRestore; i++) {
                const index = usedIndices[i];
                const indexPosition = resource.used.indexOf(index);
                if (indexPosition !== -1) {
                    resource.used.splice(indexPosition, 1);
                    pointsRestored++;
                }
            }
        }

        function restoreAllResourceBoxes(resourceType) {
            if (!currentCharacter.resources || !currentCharacter.resources[resourceType]) return;
            
            // Clear all used boxes
            currentCharacter.resources[resourceType].used = [];
            
            // Reset temporary points to 0
            currentCharacter.resources[resourceType].temp = 0;
        }

        function restoreArmorSlots(pointsToRestore) {
            if (!currentCharacter.armorSlots) return;
            
            const armorSlots = currentCharacter.armorSlots;
            const filledIndices = [...armorSlots.filled].sort((a, b) => b - a); // Sort descending
            
            let pointsRestored = 0;
            
            // Remove from highest indices first (rightmost, bottom row first)
            for (let i = 0; i < filledIndices.length && pointsRestored < pointsToRestore; i++) {
                const index = filledIndices[i];
                const indexPosition = armorSlots.filled.indexOf(index);
                if (indexPosition !== -1) {
                    armorSlots.filled.splice(indexPosition, 1);
                    pointsRestored++;
                }
            }
        }

        function restoreAllArmorSlots() {
            if (!currentCharacter.armorSlots) return;
            
            // Clear all filled armor slots
            currentCharacter.armorSlots.filled = [];
            
            // Reset temporary armor slots to 0
            currentCharacter.armorSlots.temporary = 0;
            currentCharacter.armorSlots.total = currentCharacter.armorSlots.permanent;
        }

        // Level Up Functions
        function showLevelUpModal() {
            if (!currentCharacter) return;
            
            const modal = document.getElementById('levelUpModal');
            const thresholdBonusText = document.getElementById('levelUpThresholdBonus');
            const spellBonusText = document.getElementById('levelUpSpellBonus');
            
            // Reset selection state
            levelUpSelectedOptions = [];
            levelUpSelectionsCount = 0;
            updateLevelUpSelectionCount();
            
            // Clear all previous selections
            modal.querySelectorAll('.level-up-option').forEach(option => {
                option.classList.remove('selected');
                option.querySelector('input').checked = false;
            });
            
            // Check ability score caps and disable options if needed
            updateLevelUpAbilityOptions();
            
            // Set the character name and threshold bonus text
            thresholdBonusText.textContent = `${currentCharacter.name} gains +1/+1 Threshold`;
            
            // Check if character is a main spell-caster class
            const mainCasterClasses = ['Cleric', 'Druid', 'Sorcerer', 'Wizard'];
            const isMainCaster = mainCasterClasses.includes(currentCharacter.class);
            
            if (isMainCaster) {
                spellBonusText.textContent = `${currentCharacter.name} gains +1 Spell (Caster Class)`;
                spellBonusText.style.display = 'block';
            } else {
                spellBonusText.style.display = 'none';
            }
            
            modal.classList.remove('hidden');
        }
        
        function updateLevelUpAbilityOptions() {
            if (!currentCharacter) return;
            
            const abilities = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
            
            abilities.forEach(ability => {
                const option = document.getElementById(`levelUp${ability.charAt(0).toUpperCase() + ability.slice(1)}`);
                if (!option) return;
                
                // Calculate current total ability score
                const currentTotal = getCurrentAbilityScore(currentCharacter, ability);
                
                // Check if at +6 cap
                if (currentTotal >= 6) {
                    option.classList.add('opacity-50', 'cursor-not-allowed');
                    option.querySelector('input').disabled = true;
                    option.querySelector('span').textContent = `+1 ${ability.toUpperCase()} (Max +6)`;
                    option.style.pointerEvents = 'none';
                } else {
                    option.classList.remove('opacity-50', 'cursor-not-allowed');
                    option.querySelector('input').disabled = false;
                    option.querySelector('span').textContent = `+1 ${ability.toUpperCase()}`;
                    option.style.pointerEvents = 'auto';
                }
            });
        }
        
        function getCurrentAbilityScore(character, ability) {
            // Calculate total including base, race, weapon, and armor bonuses
            const base = character[ability] || 0;
            const race = character.abilityScoreAllocations?.[ability] || 0;
            const primaryWeapon = character.primaryWeaponAbilityBonuses?.[ability] || 0;
            const secondaryWeapon = character.secondaryWeaponAbilityBonuses?.[ability] || 0;
            const armor = character.armorAbilityBonuses?.[ability] || 0;
            
            return base + race + primaryWeapon + secondaryWeapon + armor;
        }

        function updateLevelUpSelectionCount() {
            document.getElementById('levelUpSelectionCount').textContent = levelUpSelectionsCount;
        }

        function handleLevelUpOptionClick(optionElement) {
            const input = optionElement.querySelector('input');
            const type = optionElement.dataset.type;
            
            if (optionElement.classList.contains('selected')) {
                // Deselect
                optionElement.classList.remove('selected');
                input.checked = false;
                levelUpSelectedOptions = levelUpSelectedOptions.filter(option => option.element !== optionElement);
                levelUpSelectionsCount--;
            } else {
                // Check if we can select more
                if (levelUpSelectionsCount >= 2) {
                    showCustomDialog('Selection Limit', 'You can only select 2 options for level up.');
                    return;
                }
                
                // Select
                optionElement.classList.add('selected');
                input.checked = true;
                
                // Add to selected options
                const optionData = {
                    element: optionElement,
                    type: type
                };
                
                if (type === 'resource') {
                    optionData.resource = optionElement.dataset.resource;
                    optionData.value = parseInt(optionElement.dataset.value);
                } else if (type === 'threshold') {
                    optionData.lower = parseInt(optionElement.dataset.lower);
                    optionData.upper = parseInt(optionElement.dataset.upper);
                } else if (type === 'ability') {
                    optionData.ability = optionElement.dataset.ability;
                    optionData.value = parseInt(optionElement.dataset.value);
                }
                
                levelUpSelectedOptions.push(optionData);
                levelUpSelectionsCount++;
            }
            
            updateLevelUpSelectionCount();
        }

        function applyLevelUp() {
            if (!currentCharacter) return;
            
            if (levelUpSelectionsCount !== 2) {
                showCustomDialog('Incomplete Selection', 'You must select exactly 2 options to level up.');
                return;
            }
            
            // Increase level, defaulting to 1 if not set, and cap at 10
            currentCharacter.level = Math.min((currentCharacter.level || 1) + 1, 10);

            // Disable and grey out button if max level is reached
            if (currentCharacter.level === 10) {
                const levelUpBtn = document.getElementById('levelUpCharacter');
                levelUpBtn.disabled = true;
                levelUpBtn.classList.add('opacity-50', 'cursor-not-allowed');
                levelUpBtn.classList.remove('hover:bg-green-600');
            }
        
            
            // Apply automatic threshold bonus (+1/+1)
            currentCharacter.thresholdLower = (currentCharacter.thresholdLower || 0) + 1;
            currentCharacter.thresholdUpper = (currentCharacter.thresholdUpper || 0) + 1;
            
            // Apply automatic spell caster bonus if applicable
            const mainCasterClasses = ['Cleric', 'Druid', 'Sorcerer', 'Wizard'];
            if (mainCasterClasses.includes(currentCharacter.class)) {
                // Increase spell max
                currentCharacter.spellMax = (currentCharacter.spellMax || 0) + 1;
                
                // Update resources object
                if (!currentCharacter.resources) {
                    currentCharacter.resources = {
                        hp: { max: 0, used: [], temp: 0 },
                        stress: { max: 0, used: [], temp: 0 },
                        class: { max: 0, used: [], temp: 0 },
                        spell: { max: 0, used: [], temp: 0 }
                    };
                }
                
                if (!currentCharacter.resources.spell) {
                    currentCharacter.resources.spell = { max: 0, used: [], temp: 0 };
                }
                
                currentCharacter.resources.spell.max += 1;
            }
            
            // Apply weapon proficiency level up (fill one circle if available)
            applyWeaponProficiencyLevelUp();
            
            // Apply selected options
            levelUpSelectedOptions.forEach(option => {
                if (option.type === 'resource') {
                    const resource = option.resource;
                    
                    if (resource === 'armor') {
                        // Special handling for armor - increases both armor value and slots
                        currentCharacter.armor = (currentCharacter.armor || 0) + option.value;
                        
                        // Ensure armor slots are initialized and updated
                        if (!currentCharacter.armorSlots) {
                            currentCharacter.armorSlots = { 
                                total: 0, 
                                filled: [],
                                permanent: 0,
                                temporary: 0
                            };
                        }
                        
                        // Update both total and permanent slots
                        currentCharacter.armorSlots.total += option.value;
                        currentCharacter.armorSlots.permanent += option.value;
                    } else {
                        // Handle HP, Stress, Class, Spell
                        const maxKey = resource + 'Max';
                        currentCharacter[maxKey] = (currentCharacter[maxKey] || 0) + option.value;
                        
                        // Update resources object
                        if (!currentCharacter.resources) {
                            currentCharacter.resources = {
                                hp: { max: 0, used: [], temp: 0 },
                                stress: { max: 0, used: [], temp: 0 },
                                class: { max: 0, used: [], temp: 0 },
                                spell: { max: 0, used: [], temp: 0 }
                            };
                        }
                        
                        if (!currentCharacter.resources[resource]) {
                            currentCharacter.resources[resource] = { max: 0, used: [], temp: 0 };
                        }
                        
                        currentCharacter.resources[resource].max += option.value;
                    }
                } else if (option.type === 'threshold') {
                    // Additional threshold bonus (on top of the automatic +1/+1)
                    currentCharacter.thresholdLower = (currentCharacter.thresholdLower || 0) + option.lower;
                    currentCharacter.thresholdUpper = (currentCharacter.thresholdUpper || 0) + option.upper;
                } else if (option.type === 'ability') {
                    // Increase ability score
                    const ability = option.ability;
                    currentCharacter[ability] = (currentCharacter[ability] || 0) + option.value;
                }
            });
            
            // Save and refresh
            saveCharacters();
            populateCharacterSheet(currentCharacter);
            updateCharacterDisplay();
            
            // Close modal
            document.getElementById('levelUpModal').classList.add('hidden');
           
            /*
            // Show success message
            showCustomDialog('Level Up Complete!', `${currentCharacter.name} is now level ${currentCharacter.level}!`);*/
        }

        // Weapon and armor system functions
        function showWeaponModal(weaponType) {
            currentWeaponType = weaponType;
            const modal = document.getElementById('weaponModal');
            const title = document.getElementById('weaponModalTitle');
            const weaponList = document.getElementById('weaponList');
            
            // Clear previous selection
            selectedWeapon = null;
            selectedArmor = null;
            
            // Set modal title and select appropriate database
            let database, titleText, buttonText;
            if (weaponType === 'armor') {
                database = armorDatabase;
                titleText = 'Select Armor';
                buttonText = 'Add Armor';
            } else {
                database = weaponType === 'primary' ? primaryWeaponDatabase : secondaryWeaponDatabase;
                titleText = weaponType === 'primary' ? 'Select Primary Weapon' : 'Select Secondary Weapon';
                buttonText = 'Add Weapon';
            }
            
            title.textContent = titleText;
            document.getElementById('confirmWeapon').textContent = buttonText;
            
            // Populate list
            weaponList.innerHTML = database.map((item, index) => {
                if (weaponType === 'armor') {
                    return `
                        <div class="weapon-item" data-weapon-index="${index}">
                            <div class="flex items-center">
                                <input type="radio" name="weaponSelect" class="mr-3" value="${index}">
                                <div class="flex-1">
                                    <div class="font-semibold">${item.name} | ${item.thresholdLower} / ${item.thresholdUpper} | +${item.armor} Armor</div>
                                    ${item.feature && item.feature !== 'Nothing' ? `<div class="text-sm text-gray-600 dark:text-gray-400 mt-1">Feature: ${item.feature}</div>` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="weapon-item" data-weapon-index="${index}">
                            <div class="flex items-center">
                                <input type="radio" name="weaponSelect" class="mr-3" value="${index}">
                                <div class="flex-1">
                                    <div class="font-semibold">${item.name} | ${item.trait} / ${item.range} | ${item.damage}</div>
                                    ${item.feature ? `<div class="text-sm text-gray-600 dark:text-gray-400 mt-1">Feature: ${item.feature}</div>` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
            
            // Add event listeners to items
            weaponList.querySelectorAll('.weapon-item').forEach(item => {
                item.addEventListener('click', function() {
                    const radio = this.querySelector('input[type="radio"]');
                    radio.checked = true;
                    
                    if (weaponType === 'armor') {
                        selectedArmor = database[parseInt(radio.value)];
                    } else {
                        selectedWeapon = database[parseInt(radio.value)];
                    }
                    
                    // Update visual selection
                    weaponList.querySelectorAll('.weapon-item').forEach(w => w.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            modal.classList.remove('hidden');
        }

        function addWeaponToCharacter() {
            if ((!selectedWeapon && !selectedArmor) || !currentCharacter || !currentWeaponType) return;
            
            if (currentWeaponType === 'armor') {
                if (!selectedArmor) return;
                
                // Check if character already has an actual armor item (not armor bonuses from weapons)
                if (currentCharacter.armorItem) {
                    showCustomDialog('Armor Limit', 'Character already has armor. Remove the current armor first.');
                    return;
                }
                
                // Add armor to character
                currentCharacter.armorItem = { ...selectedArmor };
                
                // Apply armor bonuses
                applyArmorBonuses(selectedArmor.bonuses);
                
            } else {
                if (!selectedWeapon) return;
                
                const weaponProperty = currentWeaponType === 'primary' ? 'primaryWeapon' : 'secondaryWeapon';
                
                // Check if character already has this type of weapon
                if (currentCharacter[weaponProperty]) {
                    showCustomDialog('Weapon Limit', `Character already has a ${currentWeaponType} weapon. Remove the current weapon first.`);
                    return;
                }
                
                // Add weapon to character
                currentCharacter[weaponProperty] = { ...selectedWeapon };
                
                // Apply weapon bonuses (including automatic armor slot addition)
                applyWeaponBonuses(currentCharacter[weaponProperty].bonuses, currentWeaponType);
            }
            
            // Update display
            updateWeaponDisplay();
            
            // Save changes
            saveCharacters();
            
            // Close modal
            document.getElementById('weaponModal').classList.add('hidden');
        }

        function applyWeaponBonuses(bonuses, weaponType) {
            if (!currentCharacter || !bonuses) return;
            
            const bonusProperty = weaponType === 'primary' ? 'primaryWeaponBonuses' : 'secondaryWeaponBonuses';
            const abilityBonusProperty = weaponType === 'primary' ? 'primaryWeaponAbilityBonuses' : 'secondaryWeaponAbilityBonuses';
            
            // Initialize weapon bonuses if not present
            if (!currentCharacter[bonusProperty]) {
                currentCharacter[bonusProperty] = {};
            }
            
            // Apply bonuses to character stats
            Object.keys(bonuses).forEach(stat => {
                const bonus = bonuses[stat];
                currentCharacter[bonusProperty][stat] = bonus;
                
                // Update the actual character stat
                if (stat === 'evasion') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) + bonus;
                } else if (stat === 'armor') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) + bonus;
                    // AUTOMATICALLY ADD ARMOR SLOTS when armor increases
                    if (!currentCharacter.armorSlots) {
                        currentCharacter.armorSlots = { 
                            total: 0, 
                            filled: [],
                            permanent: 0,
                            temporary: 0
                        };
                    }
                    currentCharacter.armorSlots.total += bonus;
                    currentCharacter.armorSlots.permanent += bonus;
                } else if (stat === 'hp' || stat === 'stress' || stat === 'class' || stat === 'spell') {
                    // Update max values
                    const maxKey = stat + 'Max';
                    currentCharacter[maxKey] = (currentCharacter[maxKey] || 0) + bonus;
                    // Update resources object
                    if (currentCharacter.resources && currentCharacter.resources[stat]) {
                        currentCharacter.resources[stat].max += bonus;
                    }
                } else if (stat === 'thresholdLower' || stat === 'thresholdUpper') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) + bonus;
                } else if (['str', 'dex', 'con', 'int', 'wis', 'cha'].includes(stat)) {
                    // Apply ability score bonuses
                    if (!currentCharacter[abilityBonusProperty]) {
                        currentCharacter[abilityBonusProperty] = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
                    }
                    currentCharacter[abilityBonusProperty][stat] = bonus;
                }
            });
            
            // Refresh the character sheet display
            populateCharacterSheet(currentCharacter);
        }

        function applyArmorBonuses(bonuses) {
            if (!currentCharacter || !bonuses) return;
            
            // Disable Unarmored Defense when armor is added
            if (currentCharacter.unarmoredDefenseActive) {
                removeUnarmoredDefenseBonuses();
                currentCharacter.unarmoredDefenseActive = false;
                // Update the checkbox in the UI
                const checkbox = document.getElementById('unarmoredDefenseToggle');
                if (checkbox) {
                    checkbox.checked = false;
                }
            }
            
            // Initialize armor bonuses if not present
            if (!currentCharacter.armorBonuses) {
                currentCharacter.armorBonuses = {};
            }
            if (!currentCharacter.armorAbilityBonuses) {
                currentCharacter.armorAbilityBonuses = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            }
            
            // Apply bonuses to character stats
            Object.keys(bonuses).forEach(stat => {
                const bonus = bonuses[stat];
                currentCharacter.armorBonuses[stat] = bonus;
                
                // Update the actual character stat
                if (stat === 'evasion') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) + bonus;
                } else if (stat === 'armor') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) + bonus;
                    // AUTOMATICALLY ADD ARMOR SLOTS when armor increases
                    if (!currentCharacter.armorSlots) {
                        currentCharacter.armorSlots = { 
                            total: 0, 
                            filled: [],
                            permanent: 0,
                            temporary: 0
                        };
                    }
                    currentCharacter.armorSlots.total += bonus;
                    currentCharacter.armorSlots.permanent += bonus;
                } else if (stat === 'hp' || stat === 'stress' || stat === 'class' || stat === 'spell') {
                    // Update max values
                    const maxKey = stat + 'Max';
                    currentCharacter[maxKey] = (currentCharacter[maxKey] || 0) + bonus;
                    // Update resources object
                    if (currentCharacter.resources && currentCharacter.resources[stat]) {
                        currentCharacter.resources[stat].max += bonus;
                    }
                } else if (stat === 'thresholdLower' || stat === 'thresholdUpper') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) + bonus;
                } else if (['str', 'dex', 'con', 'int', 'wis', 'cha'].includes(stat)) {
                    // Apply ability score bonuses
                    currentCharacter.armorAbilityBonuses[stat] = bonus;
                }
            });
            
            // Refresh the character sheet display
            populateCharacterSheet(currentCharacter);
        }

        function removeWeaponBonuses(bonuses, weaponType) {
            if (!currentCharacter || !bonuses) return;
            
            const bonusProperty = weaponType === 'primary' ? 'primaryWeaponBonuses' : 'secondaryWeaponBonuses';
            const abilityBonusProperty = weaponType === 'primary' ? 'primaryWeaponAbilityBonuses' : 'secondaryWeaponAbilityBonuses';
            
            // Remove bonuses from character stats
            Object.keys(bonuses).forEach(stat => {
                const bonus = bonuses[stat];
                
                // Remove the actual bonus from character stat
                if (stat === 'evasion') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) - bonus;
                } else if (stat === 'armor') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) - bonus;
                    // AUTOMATICALLY REMOVE ARMOR SLOTS when armor decreases
                    if (currentCharacter.armorSlots) {
                        currentCharacter.armorSlots.total = Math.max(0, currentCharacter.armorSlots.total - bonus);
                        currentCharacter.armorSlots.permanent = Math.max(0, currentCharacter.armorSlots.permanent - bonus);
                        // Remove filled states that are now beyond the total
                        currentCharacter.armorSlots.filled = currentCharacter.armorSlots.filled.filter(index => index < currentCharacter.armorSlots.total);
                    }
                } else if (stat === 'hp' || stat === 'stress' || stat === 'class' || stat === 'spell') {
                    // Update max values
                    const maxKey = stat + 'Max';
                    currentCharacter[maxKey] = (currentCharacter[maxKey] || 0) - bonus;
                    // Update resources object
                    if (currentCharacter.resources && currentCharacter.resources[stat]) {
                        currentCharacter.resources[stat].max -= bonus;
                        // Ensure max doesn't go below 0
                        if (currentCharacter.resources[stat].max < 0) {
                            currentCharacter.resources[stat].max = 0;
                        }
                    }
                } else if (stat === 'thresholdLower' || stat === 'thresholdUpper') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) - bonus;
                } else if (['str', 'dex', 'con', 'int', 'wis', 'cha'].includes(stat)) {
                    // Remove ability score bonuses
                    if (currentCharacter[abilityBonusProperty]) {
                        currentCharacter[abilityBonusProperty][stat] = 0;
                    }
                }
            });
            
            // Clear weapon bonuses tracking
            currentCharacter[bonusProperty] = {};
            if (currentCharacter[abilityBonusProperty]) {
                currentCharacter[abilityBonusProperty] = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            }
            
            // Refresh the character sheet display
            populateCharacterSheet(currentCharacter);
        }

        function removeArmorBonuses(bonuses) {
            if (!currentCharacter || !bonuses) return;
            
            // Remove bonuses from character stats
            Object.keys(bonuses).forEach(stat => {
                const bonus = bonuses[stat];
                
                // Remove the actual bonus from character stat
                if (stat === 'evasion') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) - bonus;
                } else if (stat === 'armor') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) - bonus;
                    // AUTOMATICALLY REMOVE ARMOR SLOTS when armor decreases
                    if (currentCharacter.armorSlots) {
                        currentCharacter.armorSlots.total = Math.max(0, currentCharacter.armorSlots.total - bonus);
                        currentCharacter.armorSlots.permanent = Math.max(0, currentCharacter.armorSlots.permanent - bonus);
                        // Remove filled states that are now beyond the total
                        currentCharacter.armorSlots.filled = currentCharacter.armorSlots.filled.filter(index => index < currentCharacter.armorSlots.total);
                    }
                } else if (stat === 'hp' || stat === 'stress' || stat === 'class' || stat === 'spell') {
                    // Update max values
                    const maxKey = stat + 'Max';
                    currentCharacter[maxKey] = (currentCharacter[maxKey] || 0) - bonus;
                    // Update resources object
                    if (currentCharacter.resources && currentCharacter.resources[stat]) {
                        currentCharacter.resources[stat].max -= bonus;
                        // Ensure max doesn't go below 0
                        if (currentCharacter.resources[stat].max < 0) {
                            currentCharacter.resources[stat].max = 0;
                        }
                    }
                } else if (stat === 'thresholdLower' || stat === 'thresholdUpper') {
                    currentCharacter[stat] = (currentCharacter[stat] || 0) - bonus;
                } else if (['str', 'dex', 'con', 'int', 'wis', 'cha'].includes(stat)) {
                    // Remove ability score bonuses
                    if (currentCharacter.armorAbilityBonuses) {
                        currentCharacter.armorAbilityBonuses[stat] = 0;
                    }
                }
            });
            
            // Clear armor bonuses tracking
            currentCharacter.armorBonuses = {};
            if (currentCharacter.armorAbilityBonuses) {
                currentCharacter.armorAbilityBonuses = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            }
            
            // Re-enable Unarmored Defense if character was using it before
            if ((currentCharacter.class === 'Barbarian' || currentCharacter.class === 'Monk')) {
                // Auto-enable Unarmored Defense when armor is removed
                currentCharacter.unarmoredDefenseActive = true;
                applyUnarmoredDefenseBonuses();
            }
            
            // Refresh the character sheet display (this will update Unarmored Defense display)
            populateCharacterSheet(currentCharacter);
        }

        function updateWeaponDisplay() {
            const primaryWeaponDisplay = document.getElementById('primaryWeaponDisplay');
            const secondaryWeaponDisplay = document.getElementById('secondaryWeaponDisplay');
            const armorDisplay = document.getElementById('armorDisplay');
            
            // Update primary weapon display
            if (!currentCharacter || !currentCharacter.primaryWeapon) {
                primaryWeaponDisplay.innerHTML = `
                    <button id="addPrimaryWeapon" class="w-full px-3 py-2 border border-dashed border-gray-400 dark:border-gray-500 rounded text-sm text-gray-600 dark:text-gray-400 hover:border-primary hover:text-primary transition-colors">
                        <i class="fas fa-plus mr-1"></i>Add Primary Weapon
                    </button>
                `;
                
                // Re-attach event listener
                document.getElementById('addPrimaryWeapon').addEventListener('click', () => showWeaponModal('primary'));
            } else {
                const weapon = currentCharacter.primaryWeapon;
                primaryWeaponDisplay.innerHTML = `
                    <div class="weapon-display">
                        <i class="fas fa-times weapon-remove" title="Remove weapon" data-weapon-type="primary"></i>
                        <div class="font-semibold">${weapon.name} | ${weapon.trait} / ${weapon.range} | ${weapon.damage}</div>
                        ${weapon.feature ? `<div class="text-sm text-gray-600 dark:text-gray-400 mt-1">Feature: ${weapon.feature}</div>` : ''}
                    </div>
                `;
                
                // Add remove event listener
                primaryWeaponDisplay.querySelector('.weapon-remove').addEventListener('click', () => showWeaponRemovalModal('primary'));
            }
            
            // Update secondary weapon display
            if (!currentCharacter || !currentCharacter.secondaryWeapon) {
                secondaryWeaponDisplay.innerHTML = `
                    <button id="addSecondaryWeapon" class="w-full px-3 py-2 border border-dashed border-gray-400 dark:border-gray-500 rounded text-sm text-gray-600 dark:text-gray-400 hover:border-primary hover:text-primary transition-colors">
                        <i class="fas fa-plus mr-1"></i>Add Secondary Weapon
                    </button>
                `;
                
                // Re-attach event listener
                document.getElementById('addSecondaryWeapon').addEventListener('click', () => showWeaponModal('secondary'));
            } else {
                const weapon = currentCharacter.secondaryWeapon;
                secondaryWeaponDisplay.innerHTML = `
                    <div class="weapon-display">
                        <i class="fas fa-times weapon-remove" title="Remove weapon" data-weapon-type="secondary"></i>
                        <div class="font-semibold">${weapon.name} | ${weapon.trait} / ${weapon.range} | ${weapon.damage}</div>
                        ${weapon.feature ? `<div class="text-sm text-gray-600 dark:text-gray-400 mt-1">Feature: ${weapon.feature}</div>` : ''}
                    </div>
                `;
                
                // Add remove event listener
                secondaryWeaponDisplay.querySelector('.weapon-remove').addEventListener('click', () => showWeaponRemovalModal('secondary'));
            }
            
            // Update armor display
            if (!currentCharacter || !currentCharacter.armorItem) {
                armorDisplay.innerHTML = `
                    <button id="addArmor" class="w-full px-3 py-2 border border-dashed border-gray-400 dark:border-gray-500 rounded text-sm text-gray-600 dark:text-gray-400 hover:border-primary hover:text-primary transition-colors">
                        <i class="fas fa-plus mr-1"></i>Add Armor
                    </button>
                `;
                
                // Re-attach event listener
                document.getElementById('addArmor').addEventListener('click', () => showWeaponModal('armor'));
            } else {
                const armor = currentCharacter.armorItem;
                armorDisplay.innerHTML = `
                    <div class="weapon-display">
                        <i class="fas fa-times weapon-remove" title="Remove armor" data-weapon-type="armor"></i>
                        <div class="font-semibold">${armor.name} | ${armor.thresholdLower} / ${armor.thresholdUpper} | +${armor.armor} Armor</div>
                        ${armor.feature && armor.feature !== 'Nothing' ? `<div class="text-sm text-gray-600 dark:text-gray-400 mt-1">Feature: ${armor.feature}</div>` : ''}
                    </div>
                `;
                
                // Add remove event listener
                armorDisplay.querySelector('.weapon-remove').addEventListener('click', () => showWeaponRemovalModal('armor'));
            }
        }

        function showWeaponRemovalModal(weaponType) {
            currentWeaponType = weaponType;
            const modal = document.getElementById('weaponRemovalModal');
            const title = document.getElementById('weaponRemovalTitle');
            
            if (weaponType === 'armor') {
                title.textContent = 'Remove Armor';
            } else {
                title.textContent = weaponType === 'primary' ? 'Remove Primary Weapon' : 'Remove Secondary Weapon';
            }
            modal.classList.remove('hidden');
        }

        function removeWeapon() {
            if (!currentCharacter || !currentWeaponType) return;
            
            if (currentWeaponType === 'armor') {
                if (!currentCharacter.armorItem) return;
                
                // Check if this is Unarmored Defense armor
                const isUnarmoredDefenseArmor = currentCharacter.armorItem.isUnarmoredDefense;
                
                // Remove armor bonuses
                removeArmorBonuses(currentCharacter.armorItem.bonuses);
                
                // Remove armor from character
                delete currentCharacter.armorItem;
                
                // If it was Unarmored Defense armor, also uncheck the checkbox and update status
                if (isUnarmoredDefenseArmor) {
                    currentCharacter.unarmoredDefenseActive = false;
                    currentCharacter.evasion = currentCharacter.normalEvasion;
                    
                    // Update the checkbox in the UI
                    const checkbox = document.getElementById('unarmoredDefenseToggle');
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                }
            } else {
                const weaponProperty = currentWeaponType === 'primary' ? 'primaryWeapon' : 'secondaryWeapon';
                
                if (!currentCharacter[weaponProperty]) return;
                
                // Remove weapon bonuses
                removeWeaponBonuses(currentCharacter[weaponProperty].bonuses, currentWeaponType);
                
                // Remove weapon from character
                delete currentCharacter[weaponProperty];
            }
            
            // Update display
            updateWeaponDisplay();
            
            // Save changes
            saveCharacters();
            
            // Refresh the character sheet to update all displays
            populateCharacterSheet(currentCharacter);
            
            // Close modal
            document.getElementById('weaponRemovalModal').classList.add('hidden');
        }

        // ENHANCED ARMOR SYSTEM FUNCTIONS
        function generateArmorCircles(character) {
            const container = document.getElementById('armorCircles');
            const armorValue = character.armor || 0;
            
            // Ensure armor slots are properly initialized and synced with armor value
            if (!character.armorSlots) {
                character.armorSlots = { 
                    total: armorValue, 
                    filled: [],
                    permanent: armorValue,  // Track permanent vs temporary slots
                    temporary: 0
                };
            } else {
                // Ensure armor slots total is at least equal to armor value
                if (character.armorSlots.total < armorValue) {
                    character.armorSlots.total = armorValue;
                }
                
                // Initialize permanent/temporary tracking if missing
                if (character.armorSlots.permanent === undefined) {
                    character.armorSlots.permanent = armorValue;
                }
                if (character.armorSlots.temporary === undefined) {
                    character.armorSlots.temporary = Math.max(0, character.armorSlots.total - armorValue);
                }
            }
            
            const armorSlots = character.armorSlots;
            
            // Update armor slots display
            updateArmorSlotsDisplay(character);
            
            container.innerHTML = '';
            
            for (let i = 0; i < 12; i++) {
                const circle = document.createElement('div');
                circle.className = 'armor-circle';
                circle.dataset.index = i;
                
                // Determine circle type and style
                if (i < armorSlots.permanent) {
                    // Permanent armor slots (from base armor value)
                    circle.classList.add('solid-border');
                    circle.title = 'Permanent Armor Slot';
                } else if (i < armorSlots.total) {
                    // Temporary armor slots
                    circle.classList.add('solid-border', 'temp-armor-slot');
                    circle.title = 'Temporary Armor Slot';
                } else {
                    // No armor slot available
                    circle.title = 'Click to add temporary armor slots';
                }
                
                // Set filled state
                if (armorSlots.filled.includes(i)) {
                    circle.classList.add('filled');
                }
                
                // Only allow clicking on circles within total slots range
                if (i < armorSlots.total) {
                    circle.addEventListener('click', function() {
                        toggleArmorCircle(parseInt(this.dataset.index));
                    });
                    circle.style.cursor = 'pointer';
                } else {
                    // Show temp slot modal when clicking beyond available slots
                    circle.addEventListener('click', function() {
                        showArmorSlotsModal();
                    });
                    circle.style.cursor = 'pointer';
                    circle.classList.add('hover:border-primary');
                }
                
                container.appendChild(circle);
            }
        }

        function updateArmorSlotsDisplay(character) {
            if (!character.armorSlots) return;
            
            const filledSlots = character.armorSlots.filled.length;
            const totalSlots = character.armorSlots.total;
            const tempSlots = character.armorSlots.temporary || 0;
            
            // Update the armor slots count display
            const slotsCountElement = document.getElementById('armorSlotsCount');
            const tempArmorCountElement = document.getElementById('tempArmorCount');
            
            if (slotsCountElement) {
                slotsCountElement.textContent = `${filledSlots}/${totalSlots}`;
            }
            
            if (tempArmorCountElement) {
                tempArmorCountElement.textContent = `+${tempSlots} temp`;
            }
        }
        
        function toggleArmorCircle(index) {
            if (!currentCharacter) return;
            
            if (!currentCharacter.armorSlots) {
                currentCharacter.armorSlots = { 
                    total: currentCharacter.armor || 0, 
                    filled: [],
                    permanent: currentCharacter.armor || 0,
                    temporary: 0
                };
            }
            
            const filledIndex = currentCharacter.armorSlots.filled.indexOf(index);
            if (filledIndex > -1) {
                // Remove from filled
                currentCharacter.armorSlots.filled.splice(filledIndex, 1);
            } else {
                // Add to filled
                currentCharacter.armorSlots.filled.push(index);
            }
            
            generateArmorCircles(currentCharacter);
            saveCharacters();
        }
        
        function showArmorSlotsModal() {
            if (!currentCharacter) return;
            
            const modal = document.getElementById('armorSlotsModal');
            
            // Initialize armor slots if missing
            if (!currentCharacter.armorSlots) {
                currentCharacter.armorSlots = { 
                    total: currentCharacter.armor || 0, 
                    filled: [],
                    permanent: currentCharacter.armor || 0,
                    temporary: 0
                };
            }
            
            // Update modal display
            document.getElementById('currentArmorSlots').textContent = currentCharacter.armorSlots.total;
            document.getElementById('permanentArmorSlots').textContent = currentCharacter.armorSlots.permanent;
            document.getElementById('temporaryArmorSlots').textContent = currentCharacter.armorSlots.temporary;
            
            document.getElementById('armorSlotsAmount').value = '';
            modal.classList.remove('hidden');
            document.getElementById('armorSlotsAmount').focus();
        }
        
        function adjustArmorSlots(amount, isAdd) {
            if (!currentCharacter || !amount || amount < 1) return;
            
            // Ensure armor slots are initialized
            if (!currentCharacter.armorSlots) {
                currentCharacter.armorSlots = { 
                    total: currentCharacter.armor || 0, 
                    filled: [],
                    permanent: currentCharacter.armor || 0,
                    temporary: 0
                };
            }
            
            if (isAdd) {
                // Add temporary slots above the base amount
                currentCharacter.armorSlots.total = Math.min(12, currentCharacter.armorSlots.total + amount);
                currentCharacter.armorSlots.temporary += amount;
            } else {
                // Remove slots but never go below the permanent armor slots
                const newTotal = Math.max(currentCharacter.armorSlots.permanent, currentCharacter.armorSlots.total - amount);
                const slotsRemoved = currentCharacter.armorSlots.total - newTotal;
                
                currentCharacter.armorSlots.total = newTotal;
                currentCharacter.armorSlots.temporary = Math.max(0, currentCharacter.armorSlots.temporary - slotsRemoved);
                
                // Remove filled states that are now beyond the total
                currentCharacter.armorSlots.filled = currentCharacter.armorSlots.filled.filter(index => index < newTotal);
            }
            
            generateArmorCircles(currentCharacter);
            saveCharacters();
            
            document.getElementById('armorSlotsModal').classList.add('hidden');
        }

        // Random character generation functions
        function generateRandomName() {
            const firstNames = ['Aiden', 'Aria', 'Bjrn', 'Cara', 'Darius', 'Elara', 'Felix', 'Gwen', 'Harren', 'Isla', 'Jaxon', 'Kira', 'Lyra', 'Magnus', 'Nora', 'Orion', 'Piper', 'Quinn', 'Raven', 'Senna', 'Thane', 'Uma', 'Vale', 'Wren', 'Xara', 'Zara'];
            const lastNames = ['Ashworth', 'Blackwood', 'Brightblade', 'Crowley', 'Darkbane', 'Emberheart', 'Frostwick', 'Goldhammer', 'Ironfoot', 'Nightwhisper', 'Stormwind', 'Thornfield', 'Wildmane'];
            
            const firstName = firstNames[Math.floor(Math.random() * firstNames.length)];
            const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
            return `${firstName} ${lastName}`;
        }

        function getRandomArrayElement(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        function createRandomCharacter() {
            const races = ['Assaimar', 'Dragonborn', 'Dwarf', 'Elf', 'Gnome', 'Halfling', 'Human', 'Orc', 'Tiefling'];
            const classes = ['Barbarian', 'Bard', 'Cleric', 'Druid', 'Fighter', 'Monk', 'Paladin', 'Ranger', 'Rogue', 'Sorcerer', 'Warlock', 'Wizard'];
            
            const name = generateRandomName();
            const race = getRandomArrayElement(races);
            const characterClass = getRandomArrayElement(classes);
            
            // Get race and class data
            const raceInfo = raceData[race];
            const classInfo = classData[characterClass];
            
            // Create random ability score modifiers
            const shuffledModifiers = [...availableModifiers];
            for (let i = shuffledModifiers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledModifiers[i], shuffledModifiers[j]] = [shuffledModifiers[j], shuffledModifiers[i]];
            }
            
            const abilities = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
            const randomModifiers = {};
            abilities.forEach((ability, index) => {
                randomModifiers[ability] = shuffledModifiers[index];
            });
            
            // Randomly select 2 race bonuses
            const availableBonuses = [...raceInfo.bonuses];
            const selectedBonuses = [];
            for (let i = 0; i < 2 && availableBonuses.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * availableBonuses.length);
                selectedBonuses.push(availableBonuses[randomIndex]);
                availableBonuses.splice(randomIndex, 1);
            }
            
            // Calculate race bonus values
            const randomRaceBonusValues = {
                hp: 0, stress: 0, class: 0, spell: 0, evasion: raceInfo.evasion,
                thresholdLower: 0, thresholdUpper: 0
            };
            
            selectedBonuses.forEach(bonus => {
                if (bonus.type === 'threshold') {
                    randomRaceBonusValues.thresholdLower += bonus.lowerValue;
                    randomRaceBonusValues.thresholdUpper += bonus.upperValue;
                } else {
                    randomRaceBonusValues[bonus.type] += bonus.value;
                }
            });
            
            // Randomly allocate ability score points if race has them
            const randomAbilityScoreAllocations = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            if (raceInfo.abilityScores && raceInfo.abilityScores.length > 0) {
                const positivePoints = raceInfo.abilityScores.filter(s => s.value > 0).reduce((sum, s) => sum + s.value, 0);
                const negativePoints = raceInfo.abilityScores.filter(s => s.value < 0).reduce((sum, s) => sum + Math.abs(s.value), 0);
                
                // Randomly distribute positive points
                let remainingPositive = positivePoints;
                while (remainingPositive > 0) {
                    const randomAbility = getRandomArrayElement(abilities);
                    randomAbilityScoreAllocations[randomAbility]++;
                    remainingPositive--;
                }
                
                // Randomly distribute negative points
                let remainingNegative = negativePoints;
                while (remainingNegative > 0) {
                    const randomAbility = getRandomArrayElement(abilities);
                    if (randomAbilityScoreAllocations[randomAbility] > -2) { // Don't go below -2
                        randomAbilityScoreAllocations[randomAbility]--;
                        remainingNegative--;
                    }
                }
            }
            
            // Randomly select 2 proficiencies
            const availableProficiencies = [...raceInfo.proficiencies];
            const selectedProficiencies = [];
            const randomProficiencies = { str: false, dex: false, con: false, int: false, wis: false, cha: false };
            
            for (let i = 0; i < 2 && availableProficiencies.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * availableProficiencies.length);
                const proficiency = availableProficiencies[randomIndex];
                selectedProficiencies.push(proficiency);
                randomProficiencies[proficiency] = true;
                availableProficiencies.splice(randomIndex, 1);
            }
            
            // Calculate combined values (class + race bonuses)
            const hpValue = classInfo.hp + randomRaceBonusValues.hp;
            const stressValue = classInfo.stress + randomRaceBonusValues.stress;
            const classValue = classInfo.class + randomRaceBonusValues.class;
            const spellValue = classInfo.spell + randomRaceBonusValues.spell;
            const thresholdLowerValue = classInfo.thresholdLower + randomRaceBonusValues.thresholdLower;
            const thresholdUpperValue = classInfo.thresholdUpper + randomRaceBonusValues.thresholdUpper;
            const evasionValue = randomRaceBonusValues.evasion;
            
            // Create the character object
            const character = {
                id: Date.now().toString(),
                name: name,
                level: 1,
                race: race,
                class: characterClass,
                str: randomModifiers.str,
                dex: randomModifiers.dex,
                con: randomModifiers.con,
                int: randomModifiers.int,
                wis: randomModifiers.wis,
                cha: randomModifiers.cha,
                initialDex: randomModifiers.dex + (randomAbilityScoreAllocations.dex || 0),
                initialCon: randomModifiers.con + (randomAbilityScoreAllocations.con || 0),
                proficiencies: { ...randomProficiencies },
                abilityScoreAllocations: { ...randomAbilityScoreAllocations },
                initialModifiers: {
                    dex: randomModifiers.dex + (randomAbilityScoreAllocations.dex || 0),
                    con: randomModifiers.con + (randomAbilityScoreAllocations.con || 0)
                },
                hpMax: hpValue,
                stressMax: stressValue,
                classMax: classValue,
                spellMax: spellValue,
                resources: {
                    hp: { max: hpValue, used: [], temp: 0 },
                    stress: { max: stressValue, used: [], temp: 0 },
                    class: { max: classValue, used: [], temp: 0 },
                    spell: { max: spellValue, used: [], temp: 0 }
                },
                evasion: evasionValue,
                armor: 0, // Basic character starts with 0 armor
                armorSlots: { 
                    total: 0, 
                    filled: [],
                    permanent: 0,
                    temporary: 0
                },
                thresholdLower: thresholdLowerValue,
                thresholdUpper: thresholdUpperValue,
                equipment: [],
                notes: '',
                selectedRaceBonuses: [0, 1], // First two bonuses
                selectedRaceProficiencies: selectedProficiencies,
                selectedAbilityScores: [], // Filled if race has ability scores
                raceBonusValues: { ...randomRaceBonusValues },
                primaryWeapon: null,
                secondaryWeapon: null,
                armorItem: null,
                primaryWeaponBonuses: {},
                secondaryWeaponBonuses: {},
                armorBonuses: {},
                primaryWeaponAbilityBonuses: { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 },
                secondaryWeaponAbilityBonuses: { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 },
                armorAbilityBonuses: { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 },
                weaponProficiency: 1
            };
            
            return character;
        }

        // Navigation
        document.addEventListener('DOMContentLoaded', function() {
            loadCharacters();
            updateCharacterDisplay();
            
            // Add Save/Load event listeners with null checks
            const saveBtn = document.getElementById('saveCharactersBtn');
            const loadBtn = document.getElementById('loadCharactersBtn');
            const loadInput = document.getElementById('loadFileInput');
            
            if (saveBtn) {
                saveBtn.addEventListener('click', saveAllCharacters);
            }
            if (loadBtn) {
                loadBtn.addEventListener('click', intelligentLoad);
            }
            if (loadInput) {
                loadInput.addEventListener('change', handleIntelligentLoad);
            }
        });

        // Race bonus system functions
        function updateRaceOptions(selectedRace) {
            const race = raceData[selectedRace];
            if (!race) {
                hideRaceOptions();
                return;
            }

            // Show race sections
            document.getElementById('raceBonusSection').classList.remove('hidden');
            document.getElementById('raceProficiencySection').classList.remove('hidden');

            // Reset selections
            selectedRaceBonuses = [];
            selectedRaceProficiencies = [];
            selectedAbilityScores = [];
            resetRaceBonusValues();
            resetRaceAbilityBonuses();
            
            // Reset ability score proficiencies
            resetProficiencySystem();

            // Update bonus buttons (combining regular bonuses and ability scores)
            updateCombinedRaceBonusButtons(race.bonuses, race.abilityScores);
            updateRaceProficiencyButtons(race.proficiencies);
            
            // Auto-apply evasion value
            raceBonusValues.evasion = race.evasion;
            updateFieldsWithRaceBonuses();
            updateAbilityScoreResults();
        }

        function hideRaceOptions() {
            document.getElementById('raceBonusSection').classList.add('hidden');
            document.getElementById('raceProficiencySection').classList.add('hidden');
            document.getElementById('abilityScoreResultsSection').classList.add('hidden');
            selectedRaceBonuses = [];
            selectedRaceProficiencies = [];
            selectedAbilityScores = [];
            resetRaceBonusValues();
            resetRaceAbilityBonuses();
        }

        function resetRaceBonusValues() {
            raceBonusValues = {
                hp: 0,
                stress: 0,
                class: 0,
                spell: 0,
                evasion: 0,
                thresholdLower: 0,
                thresholdUpper: 0
            };
            updateFieldsWithRaceBonuses();
        }

        function resetRaceAbilityBonuses() {
            raceAbilityBonuses = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            abilityScoreAllocations = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            updateAbilityScoreResults();
            updateLiveAbilityScores();
        }

        // UPDATED FUNCTION: Creates single ability score button
        function updateCombinedRaceBonusButtons(bonuses, abilityScores) {
            const container = document.getElementById('raceBonusButtons');
            container.innerHTML = '';

            // Add regular bonus buttons
            bonuses.forEach((bonus, index) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'race-bonus-button';
                button.textContent = bonus.label;
                button.dataset.index = index;
                button.dataset.type = bonus.type;
                button.dataset.category = 'bonus';
                
                if (bonus.type === 'threshold') {
                    button.dataset.lowerValue = bonus.lowerValue;
                    button.dataset.upperValue = bonus.upperValue;
                } else {
                    button.dataset.value = bonus.value;
                }
                
                button.addEventListener('click', function() {
                    toggleRaceBonus(this);
                });

                container.appendChild(button);
            });

            // Add single ability score button if there are any ability scores
            if (abilityScores.length > 0) {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'race-bonus-button';
                
                // Create display text showing all available points
                const positiveValues = abilityScores.filter(s => s.value > 0).map(s => `+${s.value}`);
                const negativeValues = abilityScores.filter(s => s.value < 0).map(s => s.value);
                const allValues = [...positiveValues, ...negativeValues];
                
                button.textContent = `Ability Scores (${allValues.join(', ')})`;
                button.dataset.category = 'ability';
                button.dataset.scores = JSON.stringify(abilityScores);
                
                button.addEventListener('click', function() {
                    toggleAbilityScoreGroup(this);
                });

                container.appendChild(button);
            }
        }

        function updateRaceProficiencyButtons(proficiencies) {
            const container = document.getElementById('raceProficiencyButtons');
            container.innerHTML = '';

            proficiencies.forEach(ability => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'race-proficiency-button';
                button.textContent = ability.toUpperCase();
                button.dataset.ability = ability;
                
                button.addEventListener('click', function() {
                    toggleRaceProficiency(this);
                });

                container.appendChild(button);
            });
        }

        function toggleRaceBonus(button) {
            const index = parseInt(button.dataset.index);
            const type = button.dataset.type;

            if (button.classList.contains('selected')) {
                // Remove selection
                button.classList.remove('selected');
                selectedRaceBonuses = selectedRaceBonuses.filter(i => i !== index);
                
                // Remove bonus value
                if (type === 'threshold') {
                    const lowerValue = parseInt(button.dataset.lowerValue);
                    const upperValue = parseInt(button.dataset.upperValue);
                    raceBonusValues.thresholdLower -= lowerValue;
                    raceBonusValues.thresholdUpper -= upperValue;
                } else {
                    const value = parseInt(button.dataset.value);
                    raceBonusValues[type] -= value;
                }
            } else {
                // Check if we can add more selections (fixed logic)
                const abilityScoreSelected = selectedAbilityScores.length > 0 ? 1 : 0;
                const totalSelected = selectedRaceBonuses.length + abilityScoreSelected;
                if (totalSelected >= 2) {
                    showCustomDialog('Selection Limit', 'Can only select 2 total bonuses and ability scores.');
                    return;
                }
                
                button.classList.add('selected');
                selectedRaceBonuses.push(index);
                
                // Add bonus value
                if (type === 'threshold') {
                    const lowerValue = parseInt(button.dataset.lowerValue);
                    const upperValue = parseInt(button.dataset.upperValue);
                    raceBonusValues.thresholdLower += lowerValue;
                    raceBonusValues.thresholdUpper += upperValue;
                } else {
                    const value = parseInt(button.dataset.value);
                    raceBonusValues[type] += value;
                }
            }

            updateFieldsWithRaceBonuses();
        }

        // UPDATED FUNCTION: Handles single ability score button with fixed logic
        function toggleAbilityScoreGroup(button) {
            const scores = JSON.parse(button.dataset.scores);

            if (button.classList.contains('selected')) {
                // Remove selection - clear ability score allocations
                button.classList.remove('selected');
                selectedAbilityScores = [];
                
                // Clear the allocations
                resetRaceAbilityBonuses();
                updateAbilityScoreResults();
                updateLiveAbilityScores();
                
                // Hide results section if no ability scores selected
                document.getElementById('abilityScoreResultsSection').classList.add('hidden');
            } else {
                // Check if we can add more selections (fixed logic)
                const abilityScoreSelected = selectedAbilityScores.length > 0 ? 1 : 0;
                const totalSelected = selectedRaceBonuses.length + abilityScoreSelected;
                if (totalSelected >= 2) {
                    showCustomDialog('Selection Limit', 'Can only select 2 total bonuses and ability scores.');
                    return;
                }
                
                // Add selection - show modal for allocation
                showAbilityScoreAllocationModal(scores);
                button.classList.add('selected');
                
                // Mark as selected for all scores
                scores.forEach((score, index) => {
                    selectedAbilityScores.push({
                        originalIndex: index,
                        value: score.value,
                        group: score.value > 0 ? 'positive' : 'negative'
                    });
                });
            }
        }

        function showAbilityScoreAllocationModal(scores) {
            currentRaceAbilityScores = scores;
            
            const modal = document.getElementById('abilityScoreModal');
            const title = document.getElementById('abilityScoreModalTitle');
            
            // Prepare points counters
            let positivePoints = 0;
            let negativePoints = 0;
            
            scores.forEach(score => {
                if (score.value > 0) {
                    positivePoints += score.value;
                } else {
                    negativePoints += Math.abs(score.value);
                }
            });
            
            title.textContent = `Allocate Ability Score Points`;
            
            // Update points display
            document.getElementById('positivePointsRemaining').textContent = positivePoints;
            document.getElementById('negativePointsRemaining').textContent = negativePoints;
            
            // Show/hide sections based on available points
            const positiveSection = document.getElementById('positivePointsSection');
            const negativeSection = document.getElementById('negativePointsSection');
            const positiveMultiOptions = document.getElementById('positiveMultiOptions');
            const negativeMultiOptions = document.getElementById('negativeMultiOptions');
            
            if (positivePoints > 0) {
                positiveSection.classList.remove('hidden');
                if (positivePoints > 1) {
                    positiveMultiOptions.classList.remove('hidden');
                } else {
                    positiveMultiOptions.classList.add('hidden');
                }
            } else {
                positiveSection.classList.add('hidden');
            }
            
            if (negativePoints > 0) {
                negativeSection.classList.remove('hidden');
                if (negativePoints > 1) {
                    negativeMultiOptions.classList.remove('hidden');
                } else {
                    negativeMultiOptions.classList.add('hidden');
                }
            } else {
                negativeSection.classList.add('hidden');
            }
            
            // Reset all checkboxes
            modal.querySelectorAll('.ability-checkbox').forEach(checkbox => {
                checkbox.classList.remove('selected');
                checkbox.querySelector('input').checked = false;
            });
            
            // Store initial points for validation
            modal.dataset.initialPositivePoints = positivePoints;
            modal.dataset.initialNegativePoints = negativePoints;
            
            modal.classList.remove('hidden');
        }

        function toggleRaceProficiency(button) {
            const ability = button.dataset.ability;

            if (button.classList.contains('selected')) {
                // Remove selection
                button.classList.remove('selected');
                selectedRaceProficiencies = selectedRaceProficiencies.filter(a => a !== ability);
                
                // Update proficiency system
                proficiencies[ability] = false;
            } else {
                // Add selection
                if (selectedRaceProficiencies.length >= 2) {
                    showCustomDialog('Selection Limit', 'Can only select 2 proficiencies.');
                    return;
                }
                
                button.classList.add('selected');
                selectedRaceProficiencies.push(ability);
                
                // Update proficiency system
                proficiencies[ability] = true;
            }

            updateProficiencyCircles();
        }

        function updateFieldsWithRaceBonuses() {
            // Update resource fields with base class values + race bonuses
            const selectedClass = document.getElementById('charClass').value;
            const classValues = selectedClass && classData[selectedClass] ? classData[selectedClass] : {
                hp: 0, stress: 0, class: 0, spell: 0, thresholdLower: 0, thresholdUpper: 0
            };

            // Calculate combined values
            const hpValue = classValues.hp + raceBonusValues.hp;
            const stressValue = classValues.stress + raceBonusValues.stress;
            const classValue = classValues.class + raceBonusValues.class;
            const spellValue = classValues.spell + raceBonusValues.spell;
            const thresholdLowerValue = classValues.thresholdLower + raceBonusValues.thresholdLower;
            const thresholdUpperValue = classValues.thresholdUpper + raceBonusValues.thresholdUpper;
            const evasionValue = raceBonusValues.evasion;

            // Update form fields
            document.getElementById('hpMax').value = hpValue;
            document.getElementById('stressMax').value = stressValue;
            document.getElementById('classMax').value = classValue;
            document.getElementById('spellMax').value = spellValue;
            document.getElementById('thresholdLower').value = thresholdLowerValue;
            document.getElementById('thresholdUpper').value = thresholdUpperValue;
            document.getElementById('evasion').value = evasionValue;

            // Regenerate resource boxes
            generateResourceBoxes('hpBoxes', hpValue, 'hp');
            generateResourceBoxes('stressBoxes', stressValue, 'stress');
            generateResourceBoxes('classBoxes', classValue, 'class');
            generateResourceBoxes('spellBoxes', spellValue, 'spell');
        }

        function updateAbilityScoreResults() {
            const resultsDiv = document.getElementById('abilityScoreResults');
            const resultsSection = document.getElementById('abilityScoreResultsSection');
            
            if (selectedAbilityScores.length === 0) {
                resultsDiv.textContent = 'No ability scores selected';
                resultsDiv.classList.add('empty');
                resultsSection.classList.add('hidden');
                return;
            }
            
            resultsSection.classList.remove('hidden');
            resultsDiv.classList.remove('empty');
            
            // Create summary of selected ability scores
            const summary = [];
            ['str', 'dex', 'con', 'int', 'wis', 'cha'].forEach(ability => {
                const bonus = abilityScoreAllocations[ability];
                if (bonus !== 0) {
                    summary.push(`${ability.toUpperCase()} ${bonus >= 0 ? '+' : ''}${bonus}`);
                }
            });
            
            resultsDiv.textContent = summary.length > 0 ? summary.join(', ') : 'No ability scores allocated';
        }

        function updateLiveAbilityScores() {
            // Update the live display of ability scores in the character creation form
            // This updates the modifier display to show base modifier + race bonus
            updateAbilitySelectors();
        }

        // Character management
        function showCharacterList() {
            document.querySelectorAll('.character-view').forEach(view => view.classList.remove('active'));
            document.getElementById('characterList').classList.add('active');
        }

        function showCharacterCreation() {
            document.querySelectorAll('.character-view').forEach(view => view.classList.remove('active'));
            document.getElementById('characterCreation').classList.add('active');
            resetCharacterForm();
            
            // Initialize modifier system display
            setTimeout(() => {
                updateAvailableModifiers();
                updateAbilitySelectors();
                updateProficiencyCircles();
            }, 100);
        }

        function showCharacterSheet(character) {
            currentCharacter = character;
            document.querySelectorAll('.character-view').forEach(view => view.classList.remove('active'));
            document.getElementById('characterSheet').classList.add('active');
            populateCharacterSheet(character);
        }

        function updateClassValues(selectedClass) {
            updateFieldsWithRaceBonuses();
        }

        function resetCharacterForm() {
            document.getElementById('characterForm').reset();
            document.getElementById('charLevel').value = 1;
            document.getElementById('evasion').value = 0;
            document.getElementById('armor').value = 0;
            document.getElementById('thresholdLower').value = 0;
            document.getElementById('thresholdUpper').value = 0;
            resetModifierSystem();
            resetProficiencySystem();
            hideRaceOptions();
            
            // Reset resource values to 0
            document.getElementById('hpMax').value = 0;
            document.getElementById('stressMax').value = 0;
            document.getElementById('classMax').value = 0;
            document.getElementById('spellMax').value = 0;
            
            // Initialize resource boxes
            setTimeout(() => {
                initializeResourceBoxes();
            }, 100);
        }
        
        // Proficiency system functions
        function resetProficiencySystem() {
            proficiencies = { str: false, dex: false, con: false, int: false, wis: false, cha: false };
            updateProficiencyCircles();
        }
        
        function updateProficiencyCircles() {
            document.querySelectorAll('.proficiency-circle').forEach(circle => {
                const ability = circle.dataset.ability;
                if (proficiencies[ability]) {
                    circle.classList.add('proficient');
                } else {
                    circle.classList.remove('proficient');
                }
            });
        }

        function updateWeaponProficiencyCircles() {
            document.querySelectorAll('.weapon-proficiency-circle').forEach(circle => {
                const ability = circle.dataset.ability;
                if (proficiencies[ability]) {
                    circle.classList.add('proficient');
                } else {
                    circle.classList.remove('proficient');
                }
            });
        }
        
        function toggleProficiency(ability) {
            proficiencies[ability] = !proficiencies[ability];
            updateProficiencyCircles();
        }
        
        function updateSheetProficiencyCircles(character) {
            document.querySelectorAll('.stat-proficiency').forEach(circle => {
                const ability = circle.dataset.ability;
                if (character.proficiencies && character.proficiencies[ability]) {
                    circle.classList.add('proficient');
                } else {
                    circle.classList.remove('proficient');
                }
            });
        }
        
        function toggleSheetProficiency(ability) {
            if (!currentCharacter) return;
            
            if (!currentCharacter.proficiencies) {
                currentCharacter.proficiencies = { str: false, dex: false, con: false, int: false, wis: false, cha: false };
            }
            
            const currentlyProficient = currentCharacter.proficiencies[ability];
            const abilityName = ability.toUpperCase();
            const action = currentlyProficient ? 'remove' : 'add';
            const message = `Are you sure you want to ${action} proficiency in ${abilityName}? This will affect skill bonuses and other abilities.`;
            
            showProficiencyConfirmDialog(message, () => {
                currentCharacter.proficiencies[ability] = !currentCharacter.proficiencies[ability];
                updateSheetProficiencyCircles(currentCharacter);
                saveCharacters();
            });
        }
        
        function showProficiencyConfirmDialog(message, onConfirm) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4 text-orange-600 dark:text-orange-400">
                        <i class="fas fa-exclamation-triangle mr-2"></i>Proficiency Change Warning
                    </h3>
                    <p class="text-gray-700 dark:text-gray-300 mb-6">${message}</p>
                    <div class="flex justify-end space-x-3">
                        <button class="cancel-proficiency px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                        <button class="confirm-proficiency px-4 py-2 bg-orange-500 text-white hover:bg-orange-600 rounded">Confirm Change</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.querySelector('.confirm-proficiency').addEventListener('click', () => {
                onConfirm();
                modal.remove();
            });
            
            modal.querySelector('.cancel-proficiency').addEventListener('click', () => {
                modal.remove();
            });
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.remove();
                }
            });
        }
        
        // Resource box management functions
        function generateResourceBoxes(containerId, maxValue, resourceType) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            for (let i = 0; i < 12; i++) {
                const box = document.createElement('div');
                box.className = `resource-box ${i < maxValue ? 'solid' : 'dotted'}`;
                box.dataset.index = i;
                box.dataset.resourceType = resourceType;
                
                // Add click handler for character sheet boxes
                if (containerId.startsWith('sheet')) {
                    box.addEventListener('click', function() {
                        handleResourceBoxClick(this);
                    });
                }
                
                container.appendChild(box);
            }
        }
        
        function handleResourceBoxClick(box) {
            const resourceType = box.dataset.resourceType;
            const index = parseInt(box.dataset.index);
            
            // If it's a dotted box (beyond max), show temp points modal
            if (box.classList.contains('dotted')) {
                showTempPointsModal(resourceType);
                return;
            }
            
            // If it's a solid box, toggle it with ordering
            toggleResourceBoxOrdered(box);
        }
        
        function toggleResourceBoxOrdered(clickedBox) {
            const resourceType = clickedBox.dataset.resourceType;
            const clickedIndex = parseInt(clickedBox.dataset.index);
            const container = clickedBox.parentElement;
            const allBoxes = Array.from(container.querySelectorAll('.resource-box.solid, .resource-box.temp'));
            
            // Determine if we're marking used or unused
            const isMarkingUsed = !clickedBox.classList.contains('used');
            
            if (isMarkingUsed) {
                // Mark boxes from left to clicked index as used
                for (let i = 0; i <= clickedIndex; i++) {
                    const box = allBoxes.find(b => parseInt(b.dataset.index) === i);
                    if (box && (box.classList.contains('solid') || box.classList.contains('temp'))) {
                        box.classList.add('used');
                    }
                }
            } else {
                // Unmark boxes from clicked index to the right
                for (let i = clickedIndex; i < allBoxes.length; i++) {
                    const box = allBoxes.find(b => parseInt(b.dataset.index) === i);
                    if (box && (box.classList.contains('solid') || box.classList.contains('temp'))) {
                        box.classList.remove('used');
                    }
                }
            }
            
            // Save the state to character data
            if (currentCharacter) {
                if (!currentCharacter.resources) {
                    currentCharacter.resources = {
                        hp: { max: 0, used: [], temp: 0 },
                        stress: { max: 0, used: [], temp: 0 },
                        class: { max: 0, used: [], temp: 0 },
                        spell: { max: 0, used: [], temp: 0 }
                    };
                }
                
                // Update used array with all currently used boxes
                const usedBoxes = Array.from(container.querySelectorAll('.resource-box.used')).map(box => parseInt(box.dataset.index));
                currentCharacter.resources[resourceType].used = usedBoxes;
                
                saveCharacters();
                
                // Update character cards to reflect the current HP status
                updateCharacterDisplay();
            }
        }
        
        function showTempPointsModal(resourceType) {
            if (!currentCharacter) return;
            
            const modal = document.getElementById('tempPointsModal');
            const title = document.getElementById('tempPointsTitle');
            const input = document.getElementById('tempPointsAmount');
            
            const resourceName = resourceType.charAt(0).toUpperCase() + resourceType.slice(1);
            title.textContent = `Manage Temp ${resourceName}`;
            input.value = '';
            input.focus();
            
            // Get current resource data
            const resource = currentCharacter.resources?.[resourceType] || { max: 0, temp: 0 };
            const currentTotal = resource.max + (resource.temp || 0);
            const permanent = resource.max;
            const temporary = resource.temp || 0;
            
            // Update modal display
            document.getElementById('currentResourcePoints').textContent = currentTotal;
            document.getElementById('permanentResourcePoints').textContent = permanent;
            document.getElementById('temporaryResourcePoints').textContent = temporary;
            
            modal.classList.remove('hidden');
            
            // Store the resource type for the confirm handler
            modal.dataset.resourceType = resourceType;
        }
        
        function addTempPoints(resourceType, amount) {
            if (!currentCharacter || !amount || amount < 1) return;
            
            if (!currentCharacter.resources) {
                currentCharacter.resources = {
                    hp: { max: 0, used: [], temp: 0 },
                    stress: { max: 0, used: [], temp: 0 },
                    class: { max: 0, used: [], temp: 0 },
                    spell: { max: 0, used: [], temp: 0 }
                };
            }
            
            // Add temp points
            currentCharacter.resources[resourceType].temp = (currentCharacter.resources[resourceType].temp || 0) + amount;
            
            // Refresh the resource boxes display
            populateSheetResourceBoxes(currentCharacter);
            
            saveCharacters();
        }

        function removeTempPoints(resourceType) {
            if (!currentCharacter) return;
            
            if (!currentCharacter.resources) {
                return;
            }
            
            // Remove all temp points for this resource
            if (currentCharacter.resources[resourceType]) {
                const resource = currentCharacter.resources[resourceType];
                const maxBoxes = resource.max;
                
                // Remove temp points
                resource.temp = 0;
                
                // Clean up the used array - remove any indices that are now beyond the max range
                if (resource.used) {
                    resource.used = resource.used.filter(index => index < maxBoxes);
                }
                
                // Refresh the resource boxes display
                populateSheetResourceBoxes(currentCharacter);
                
                saveCharacters();
            }
        }

        function removeTempResourcePoints(resourceType, amount) {
            if (!currentCharacter || !amount || amount < 1) return;
            
            if (!currentCharacter.resources) {
                return;
            }
            
            if (currentCharacter.resources[resourceType]) {
                const resource = currentCharacter.resources[resourceType];
                
                // Only remove from temp points, never from permanent max
                const currentTemp = resource.temp || 0;
                const removeAmount = Math.min(amount, currentTemp);
                
                if (removeAmount > 0) {
                    resource.temp = Math.max(0, currentTemp - removeAmount);
                    
                    // Remove filled states for boxes that are now beyond the total
                    const newTotal = resource.max + resource.temp;
                    if (resource.used) {
                        resource.used = resource.used.filter(index => index < newTotal);
                    }
                    
                    // Refresh the resource boxes display
                    populateSheetResourceBoxes(currentCharacter);
                    
                    saveCharacters();
                } else {
                    showCustomDialog('No Temporary Points', 'There are no temporary points to remove for this resource.');
                }
            }
        }
        
        function initializeResourceBoxes() {
            // Initialize creation form boxes
            generateResourceBoxes('hpBoxes', 0, 'hp');
            generateResourceBoxes('stressBoxes', 0, 'stress');
            generateResourceBoxes('classBoxes', 0, 'class');
            generateResourceBoxes('spellBoxes', 0, 'spell');
            
            // Add event listeners to max value inputs
            document.getElementById('hpMax').addEventListener('input', function() {
                generateResourceBoxes('hpBoxes', parseInt(this.value) || 0, 'hp');
            });
            
            document.getElementById('stressMax').addEventListener('input', function() {
                generateResourceBoxes('stressBoxes', parseInt(this.value) || 0, 'stress');
            });
            
            document.getElementById('classMax').addEventListener('input', function() {
                generateResourceBoxes('classBoxes', parseInt(this.value) || 0, 'class');
            });
            
            document.getElementById('spellMax').addEventListener('input', function() {
                generateResourceBoxes('spellBoxes', parseInt(this.value) || 0, 'spell');
            });
        }
        
        function populateSheetResourceBoxes(character) {
            const resources = character.resources || {
                hp: { max: character.hpMax || 0, used: [], temp: 0 },
                stress: { max: character.stressMax || 0, used: [], temp: 0 },
                class: { max: character.classMax || 0, used: [], temp: 0 },
                spell: { max: character.spellMax || 0, used: [], temp: 0 }
            };
            
            // Helper function to create resource boxes
            function createResourceBoxes(containerId, resourceType) {
                const container = document.getElementById(containerId);
                const resource = resources[resourceType];
                const totalBoxes = resource.max + (resource.temp || 0);
                
                container.innerHTML = '';
                
                for (let i = 0; i < 12; i++) {
                    const box = document.createElement('div');
                    
                    if (i < resource.max) {
                        // Regular boxes
                        box.className = 'resource-box solid';
                    } else if (i < totalBoxes) {
                        // Temp boxes
                        box.className = 'resource-box temp';
                    } else {
                        // Dotted boxes (beyond max + temp)
                        box.className = 'resource-box dotted';
                    }
                    
                    // Mark as used if in the used array
                    if (resource.used && resource.used.includes(i)) {
                        box.classList.add('used');
                    }
                    
                    box.dataset.index = i;
                    box.dataset.resourceType = resourceType;
                    box.addEventListener('click', function() {
                        handleResourceBoxClick(this);
                    });
                    
                    container.appendChild(box);
                }
            }
            
            // Create all resource types
            createResourceBoxes('sheetHpBoxes', 'hp');
            createResourceBoxes('sheetStressBoxes', 'stress');
            createResourceBoxes('sheetClassBoxes', 'class');
            createResourceBoxes('sheetSpellBoxes', 'spell');
        }
        
        // Modifier selection system functions
        function resetModifierSystem() {
            selectedModifiers = { str: null, dex: null, con: null, int: null, wis: null, cha: null };
            usedModifiers = [];
            updateAvailableModifiers();
            updateAbilitySelectors();
        }
        
        function updateAvailableModifiers() {
            const container = document.getElementById('availableModifiers');
            const remaining = availableModifiers.filter((mod, index) => !usedModifiers.includes(index));
            
            if (remaining.length === 0) {
                container.innerHTML = '<span class="text-sm text-gray-500 dark:text-gray-400">All modifiers assigned</span>';
                return;
            }
            
            container.innerHTML = remaining.map(mod => 
                `<span class="px-2 py-1 bg-primary text-white rounded text-sm">${mod >= 0 ? '+' : ''}${mod}</span>`
            ).join('');
        }
        
        function updateAbilitySelectors() {
            document.querySelectorAll('.ability-selector').forEach(selector => {
                const ability = selector.dataset.ability;
                const display = selector.querySelector('.modifier-display');
                
                let totalModifier = selectedModifiers[ability];
                
                // Add race bonuses if they exist
                if (abilityScoreAllocations[ability] !== 0) {
                    if (totalModifier !== null) {
                        totalModifier += abilityScoreAllocations[ability];
                    }
                }
                
                if (selectedModifiers[ability] !== null) {
                    display.textContent = totalModifier >= 0 ? `+${totalModifier}` : totalModifier;
                    selector.classList.add('bg-primary', 'text-white');
                    selector.classList.remove('bg-white', 'dark:bg-gray-700');
                } else {
                    // Show race bonus only if no base modifier selected
                    if (abilityScoreAllocations[ability] !== 0) {
                        display.textContent = abilityScoreAllocations[ability] >= 0 ? `+${abilityScoreAllocations[ability]}` : abilityScoreAllocations[ability];
                        selector.classList.add('bg-green-500', 'text-white');
                        selector.classList.remove('bg-white', 'dark:bg-gray-700', 'bg-primary');
                    } else {
                        display.textContent = '--';
                        selector.classList.remove('bg-primary', 'text-white', 'bg-green-500');
                        selector.classList.add('bg-white', 'dark:bg-gray-700');
                    }
                }
            });
        }
        
        function showModifierSelection(ability) {
            const remaining = availableModifiers.filter((mod, index) => !usedModifiers.includes(index));
            
            if (remaining.length === 0) {
                showCustomDialog('No modifiers available', 'All modifiers have been assigned.');
                return;
            }
            
            // Create selection modal
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4">Select Modifier for ${ability.toUpperCase()}</h3>
                    <div class="grid grid-cols-2 gap-2 mb-4">
                        ${remaining.map((mod, index) => `
                            <button class="modifier-option px-4 py-2 border border-gray-300 dark:border-gray-600 rounded hover:bg-primary hover:text-white transition-colors" data-modifier="${mod}" data-original-index="${availableModifiers.findIndex((m, i) => m === mod && !usedModifiers.includes(i))}">
                                ${mod >= 0 ? '+' : ''}${mod}
                            </button>
                        `).join('')}
                    </div>
                    <div class="flex justify-end space-x-3">
                        <button class="cancel-modifier px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add event listeners
            modal.querySelectorAll('.modifier-option').forEach(btn => {
                btn.addEventListener('click', function() {
                    const modifier = parseInt(this.dataset.modifier);
                    const originalIndex = parseInt(this.dataset.originalIndex);
                    
                    // If this ability already has a modifier, free it up
                    if (selectedModifiers[ability] !== null) {
                        const oldIndex = availableModifiers.findIndex((mod, i) => 
                            mod === selectedModifiers[ability] && usedModifiers.includes(i)
                        );
                        if (oldIndex !== -1) {
                            usedModifiers = usedModifiers.filter(i => i !== oldIndex);
                        }
                    }
                    
                    // Assign new modifier
                    selectedModifiers[ability] = modifier;
                    usedModifiers.push(originalIndex);
                    
                    updateAvailableModifiers();
                    updateAbilitySelectors();
                    
                    modal.remove();
                });
            });
            
            modal.querySelector('.cancel-modifier').addEventListener('click', () => {
                modal.remove();
            });
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.remove();
                }
            });
        }
        
        function showCustomDialog(title, message) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4">${title}</h3>
                    <p class="text-gray-700 dark:text-gray-300 mb-4">${message}</p>
                    <div class="flex justify-end">
                        <button class="px-4 py-2 bg-primary text-white hover:bg-primary-dark rounded">OK</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.querySelector('button').addEventListener('click', () => {
                modal.remove();
            });
            
            modal.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.remove();
                }
            });
        }

        function createCharacterCard(character) {
            const resources = character.resources || {
                hp: { max: character.hpMax || 0, used: [], temp: 0 },
                stress: { max: character.stressMax || 0, used: [], temp: 0 },
                class: { max: character.classMax || 0, used: [], temp: 0 },
                spell: { max: character.spellMax || 0, used: [], temp: 0 }
            };
            
            const hpUsed = resources.hp.used.length;
            const hpMax = resources.hp.max + (resources.hp.temp || 0);
            const hpCurrent = hpMax - hpUsed;
            
            return `
                <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg hover:shadow-lg transition-shadow cursor-pointer character-card" data-id="${character.id}">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="font-semibold text-lg">${character.name}</h3>
                        <span class="text-sm text-gray-500 dark:text-gray-400">Lv.${character.level}</span>
                    </div>
                    <p class="text-gray-600 dark:text-gray-400 mb-2">${character.race} ${character.class}</p>
                    <div class="flex justify-between text-sm">
                        <span>HP: ${hpCurrent}/${hpMax}</span>
                        <span>Evasion: ${character.evasion || 0}</span>
                    </div>
                    <div class="mt-2 bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                        <div class="bg-red-500 h-2 rounded-full transition-all duration-300" style="width: ${hpMax > 0 ? (hpCurrent / hpMax) * 100 : 0}%"></div>
                    </div>
                </div>
            `;
        }

        function updateCharacterDisplay() {
            const container = document.getElementById('characterCards');
            const noCharacters = document.getElementById('noCharacters');
            
            if (characters.length === 0) {
                container.innerHTML = '';
                noCharacters.style.display = 'block';
            } else {
                noCharacters.style.display = 'none';
                container.innerHTML = characters.map(createCharacterCard).join('');
                
                // Add click handlers
                document.querySelectorAll('.character-card').forEach(card => {
                    card.addEventListener('click', function() {
                        const characterId = this.dataset.id;
                        const character = characters.find(c => c.id === characterId);
                        if (character) {
                            showCharacterSheet(character);
                        }
                    });
                });
            }
        }

        function populateCharacterSheet(character) {
            document.getElementById('sheetCharName').textContent = character.name;
            document.getElementById('sheetCharInfo').textContent = `Level ${character.level} ${character.race} ${character.class}`;
            
            // Resources
            populateSheetResourceBoxes(character);
            
            // Threshold with Unarmored Defense bonuses if applicable
            const thresholdLowerBase = character.thresholdLower || 0;
            const thresholdUpperBase = character.thresholdUpper || 0;
            
            let thresholdLowerDisplay = thresholdLowerBase;
            let thresholdUpperDisplay = thresholdUpperBase;
            
            // Apply Unarmored Defense threshold bonuses if active (allow ceremonial Unarmored Defense armor)
            if (character.unarmoredDefenseActive && (!character.armorItem || character.armorItem.isUnarmoredDefense)) {
                if (character.class === 'Monk') {
                    const currentDex = getCurrentDexModifier(character);
                    thresholdLowerDisplay += currentDex;
                    thresholdUpperDisplay += currentDex;
                } else if (character.class === 'Barbarian') {
                    const currentDex = getCurrentDexModifier(character);
                    const currentCon = getCurrentConModifier(character);
                    thresholdLowerDisplay += currentDex;
                    thresholdUpperDisplay += currentDex + currentCon;
                }
                
                // Add level-up bonuses for Barbarians and Monks
                if (character.unarmoredDefenseThresholdBonuses) {
                    thresholdLowerDisplay += character.unarmoredDefenseThresholdBonuses.lower || 0;
                    thresholdUpperDisplay += character.unarmoredDefenseThresholdBonuses.upper || 0;
                }
            }
            
            document.getElementById('thresholdLowerDisplay').textContent = thresholdLowerDisplay;
            document.getElementById('thresholdUpperDisplay').textContent = thresholdUpperDisplay;
            
            // Threshold temp boxes
            updateThresholdTempBoxes(character);
            
            // Stats (include race bonuses, weapon bonuses, and armor bonuses)
            const raceAbilityBonuses = character.abilityScoreAllocations || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const primaryWeaponAbilityBonuses = character.primaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const secondaryWeaponAbilityBonuses = character.secondaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const armorAbilityBonuses = character.armorAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            
            const displayStr = (character.str || 0) + raceAbilityBonuses.str + primaryWeaponAbilityBonuses.str + secondaryWeaponAbilityBonuses.str + armorAbilityBonuses.str;
            const displayDex = (character.dex || 0) + raceAbilityBonuses.dex + primaryWeaponAbilityBonuses.dex + secondaryWeaponAbilityBonuses.dex + armorAbilityBonuses.dex;
            const displayCon = (character.con || 0) + raceAbilityBonuses.con + primaryWeaponAbilityBonuses.con + secondaryWeaponAbilityBonuses.con + armorAbilityBonuses.con;
            const displayInt = (character.int || 0) + raceAbilityBonuses.int + primaryWeaponAbilityBonuses.int + secondaryWeaponAbilityBonuses.int + armorAbilityBonuses.int;
            const displayWis = (character.wis || 0) + raceAbilityBonuses.wis + primaryWeaponAbilityBonuses.wis + secondaryWeaponAbilityBonuses.wis + armorAbilityBonuses.wis;
            const displayCha = (character.cha || 0) + raceAbilityBonuses.cha + primaryWeaponAbilityBonuses.cha + secondaryWeaponAbilityBonuses.cha + armorAbilityBonuses.cha;
            
            document.getElementById('displayStr').textContent = displayStr >= 0 ? `+${displayStr}` : displayStr;
            document.getElementById('displayDex').textContent = displayDex >= 0 ? `+${displayDex}` : displayDex;
            document.getElementById('displayCon').textContent = displayCon >= 0 ? `+${displayCon}` : displayCon;
            document.getElementById('displayInt').textContent = displayInt >= 0 ? `+${displayInt}` : displayInt;
            document.getElementById('displayWis').textContent = displayWis >= 0 ? `+${displayWis}` : displayWis;
            document.getElementById('displayCha').textContent = displayCha >= 0 ? `+${displayCha}` : displayCha;
            
            // Proficiencies
            updateSheetProficiencyCircles(character);
            
            // Combat stats
            document.getElementById('displayEvasion').textContent = character.evasion || 0;
            document.getElementById('displayArmor').textContent = character.armor || 0;
            
            // Initialize armor slots if not present
            if (!character.armorSlots) {
                character.armorSlots = { 
                    total: character.armor || 0, 
                    filled: [],
                    permanent: character.armor || 0,
                    temporary: 0
                };
            }
            
            // Generate armor circles
            generateArmorCircles(character);
            
            // Skills (include race, weapon, and armor bonuses)
            generateSkillsList(character);
            
            // Weapon and armor display
            updateWeaponDisplay();
            
            // Update weapon proficiency circles based on character data
            if (character.weaponProficiency) {
                updateWeaponProficiencyDisplay(character.weaponProficiency);
            }
            
            // Update Unarmored Defense display
            updateUnarmoredDefenseDisplay();
            
            // Update Mage Armor display
            updateMageArmorDisplay();
            
            // Update level up button state
            updateLevelUpButtonState(character);
            
            // Update Familiar display
            updateFamiliarDisplay(character);
            
            // Update Companion display
            updateCompanionDisplay(character);
            
            // Equipment
            updateEquipmentDisplay(character);
            
            // Notes
            document.getElementById('characterNotes').value = character.notes || '';
        }

        function generateSkillsList(character) {
            const skillsList = document.getElementById('skillsList');
            skillsList.innerHTML = '';
            
            const raceAbilityBonuses = character.abilityScoreAllocations || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const primaryWeaponAbilityBonuses = character.primaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const secondaryWeaponAbilityBonuses = character.secondaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const armorAbilityBonuses = character.armorAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            
            defaultSkills.forEach(skill => {
                const baseModifier = character[skill.ability] || 0;
                const raceBonus = raceAbilityBonuses[skill.ability] || 0;
                const primaryWeaponBonus = primaryWeaponAbilityBonuses[skill.ability] || 0;
                const secondaryWeaponBonus = secondaryWeaponAbilityBonuses[skill.ability] || 0;
                const armorBonus = armorAbilityBonuses[skill.ability] || 0;
                const totalModifier = baseModifier + raceBonus + primaryWeaponBonus + secondaryWeaponBonus + armorBonus;
                
                const skillDiv = document.createElement('div');
                skillDiv.className = 'flex justify-between items-center p-2 bg-white dark:bg-gray-700 rounded hover:bg-gray-100 dark:hover:bg-gray-600 cursor-pointer';
                skillDiv.innerHTML = `
                    <span>${skill.name}</span>
                    <span class="font-semibold">${totalModifier >= 0 ? '+' : ''}${totalModifier}</span>
                `;
                skillsList.appendChild(skillDiv);
            });
        }

        function updateHealthBar(current, max) {
            const healthBar = document.getElementById('healthBar');
            const percentage = (current / max) * 100;
            healthBar.style.width = percentage + '%';
            
            // Change color based on health percentage
            if (percentage > 50) {
                healthBar.className = 'bg-green-500 h-3 rounded-full transition-all duration-300';
            } else if (percentage > 25) {
                healthBar.className = 'bg-yellow-500 h-3 rounded-full transition-all duration-300';
            } else {
                healthBar.className = 'bg-red-500 h-3 rounded-full transition-all duration-300';
            }
        }

        function updateEquipmentDisplay(character) {
            const equipmentList = document.getElementById('equipmentList');
            equipmentList.innerHTML = '';
            
            // Generate health potion circles
            generateHealthPotionCircles(character);
            
            if (!character.equipment || character.equipment.length === 0) {
                equipmentList.innerHTML = '<div class="text-gray-500 dark:text-gray-400 text-sm text-center py-4">No equipment</div>';
                return;
            }
            
            character.equipment.forEach((item, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'flex justify-between items-center p-2 bg-white dark:bg-gray-700 rounded hover:bg-gray-50 dark:hover:bg-gray-600 transition-colors';
                itemDiv.innerHTML = `
                    <button class="equipment-item-btn flex-1 text-left font-medium text-primary hover:text-primary-dark cursor-pointer" data-index="${index}">
                        ${item.name}
                    </button>
                    <div class="flex items-center space-x-2">
                        <span class="text-sm text-gray-500">x${item.quantity}</span>
                        <button class="text-red-500 hover:text-red-600 text-sm remove-equipment-btn" data-index="${index}">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                equipmentList.appendChild(itemDiv);
            });
            
            // Add event listeners for equipment item buttons
            equipmentList.querySelectorAll('.equipment-item-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = parseInt(this.dataset.index);
                    showEquipmentQuantityModal(index);
                });
            });
            
            // Add event listeners for remove buttons
            equipmentList.querySelectorAll('.remove-equipment-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = parseInt(this.dataset.index);
                    removeEquipment(index);
                });
            });
        }

        function showEquipmentQuantityModal(itemIndex) {
            if (!currentCharacter || !currentCharacter.equipment || !currentCharacter.equipment[itemIndex]) return;
            
            const item = currentCharacter.equipment[itemIndex];
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4">Adjust Quantity</h3>
                    <div class="mb-4">
                        <div class="text-gray-600 dark:text-gray-400 mb-2">${item.name}</div>
                        <div class="text-sm text-gray-500 mb-3">Current quantity: ${item.quantity}</div>
                        <input type="number" id="newQuantity" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent" value="${item.quantity}" min="1" max="99">
                    </div>
                    <div class="flex justify-end space-x-3">
                        <button class="cancel-quantity px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                        <button class="confirm-quantity px-4 py-2 bg-primary text-white hover:bg-primary-dark rounded">Update</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            const input = modal.querySelector('#newQuantity');
            input.focus();
            input.select();
            
            modal.querySelector('.confirm-quantity').addEventListener('click', () => {
                const newQuantity = parseInt(input.value);
                if (newQuantity && newQuantity > 0) {
                    currentCharacter.equipment[itemIndex].quantity = newQuantity;
                    updateEquipmentDisplay(currentCharacter);
                    saveCharacters();
                }
                modal.remove();
            });
            
            modal.querySelector('.cancel-quantity').addEventListener('click', () => {
                modal.remove();
            });
            
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const newQuantity = parseInt(input.value);
                    if (newQuantity && newQuantity > 0) {
                        currentCharacter.equipment[itemIndex].quantity = newQuantity;
                        updateEquipmentDisplay(currentCharacter);
                        saveCharacters();
                    }
                    modal.remove();
                }
            });
            
            modal.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.remove();
                }
            });
        }

        function saveCharacters() {
            // Save to localStorage for automatic persistence
            try {
                const dataToStore = {
                    version: "1.0",
                    saveDate: new Date().toISOString(),
                    characters: characters
                };
                localStorage.setItem('rpg-character-manager-data', JSON.stringify(dataToStore));
                console.log('Characters saved to localStorage:', characters.length, 'characters');
            } catch (error) {
                console.error('Error saving to localStorage:', error);
                // Could show a user notification here if desired
            }
        }

        function loadCharacters() {
            // Load from localStorage if available
            try {
                const storedData = localStorage.getItem('rpg-character-manager-data');
                if (storedData) {
                    const data = JSON.parse(storedData);
                    if (data.characters && Array.isArray(data.characters)) {
                        characters = data.characters;
                        console.log('Characters loaded from localStorage:', characters.length, 'characters');
                        return;
                    }
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
                // Fall back to empty array if there's an issue
            }
            
            // If no valid data in localStorage, start with empty array
            characters = [];
            console.log('Started with empty character list');
        }

        function removeEquipment(index) {
            if (currentCharacter && currentCharacter.equipment) {
                currentCharacter.equipment.splice(index, 1);
                updateEquipmentDisplay(currentCharacter);
                saveCharacters();
            }
        }

        function showHealthPrompt(title, callback) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4">${title}</h3>
                    <input type="number" id="healthAmount" class="w-full px-3 py-2 text-base border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 focus:ring-2 focus:ring-primary focus:border-transparent" placeholder="Amount" min="1">
                    <div class="flex justify-end space-x-3 mt-4">
                        <button class="cancel-health px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                        <button class="confirm-health px-4 py-2 bg-primary text-white hover:bg-primary-dark rounded">Confirm</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            const input = modal.querySelector('#healthAmount');
            input.focus();
            
            modal.querySelector('.confirm-health').addEventListener('click', () => {
                const amount = parseInt(input.value);
                if (amount && !isNaN(amount)) {
                    callback(amount);
                }
                modal.remove();
            });
            
            modal.querySelector('.cancel-health').addEventListener('click', () => {
                modal.remove();
            });
            
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const amount = parseInt(input.value);
                    if (amount && !isNaN(amount)) {
                        callback(amount);
                    }
                    modal.remove();
                }
            });
            
            modal.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.remove();
                }
            });
        }

        // Event listeners with null checks
        const makeRandomBtn = document.getElementById('makeRandomBtn');
        if (makeRandomBtn) {
            makeRandomBtn.addEventListener('click', function() {
                const randomCharacter = createRandomCharacter();
                characters.push(randomCharacter);
                saveCharacters();
                updateCharacterDisplay();
                showCharacterSheet(randomCharacter);
            });
        }
        
        const newCharacterBtn = document.getElementById('newCharacterBtn');
        if (newCharacterBtn) {
            newCharacterBtn.addEventListener('click', showCharacterCreation);
        }
        
        const backToList = document.getElementById('backToList');
        if (backToList) {
            backToList.addEventListener('click', showCharacterList);
        }
        
        const backToListFromSheet = document.getElementById('backToListFromSheet');
        if (backToListFromSheet) {
            backToListFromSheet.addEventListener('click', showCharacterList);
        }
        
        const cancelCreate = document.getElementById('cancelCreate');
        if (cancelCreate) {
            cancelCreate.addEventListener('click', showCharacterList);
        }

        const backToSheetFromEdit = document.getElementById('backToSheetFromEdit');
        if (backToSheetFromEdit) {
            backToSheetFromEdit.addEventListener('click', function() {
                showCharacterSheet(currentCharacter);
            });
        }
        
        const cancelEdit = document.getElementById('cancelEdit');
        if (cancelEdit) {
            cancelEdit.addEventListener('click', function() {
                showCharacterSheet(currentCharacter);
            });
        }

        // Threshold damage button event listeners
        document.addEventListener('click', function(e) {
            if (e.target.closest('.threshold-damage-button')) {
                const button = e.target.closest('.threshold-damage-button');
                const damage = parseInt(button.dataset.damage);
                applyDamage(damage);
            }
        });

        // Rest event listeners
        document.getElementById('restCharacter').addEventListener('click', showRestModal);
        document.getElementById('cancelRest').addEventListener('click', function() {
            document.getElementById('restModal').classList.add('hidden');
        });
        document.getElementById('shortRestBtn').addEventListener('click', executeShortRest);
        document.getElementById('longRestBtn').addEventListener('click', executeLongRest);

        // Rest resource selection handling
        document.addEventListener('change', function(e) {
            if (e.target.matches('#restModal input[type="checkbox"]')) {
                handleRestResourceSelection(e.target);
            }
        });

        // Level Up event listeners
        document.getElementById('levelUpCharacter').addEventListener('click', function() {
            // Check if the button is disabled before showing modal
            if (!this.disabled) {
                showLevelUpModal();
            }
        });
        document.getElementById('cancelLevelUp').addEventListener('click', function() {
            document.getElementById('levelUpModal').classList.add('hidden');
        });
        document.getElementById('confirmLevelUp').addEventListener('click', applyLevelUp);

        // Level Up option click handling
        document.addEventListener('click', function(e) {
            if (e.target.closest('.level-up-option')) {
                const option = e.target.closest('.level-up-option');
                handleLevelUpOptionClick(option);
            }
        });

        // Race selection event listener
        document.getElementById('charRace').addEventListener('change', function() {
            updateRaceOptions(this.value);
        });

        // Class selection event listener
        document.getElementById('charClass').addEventListener('change', function() {
            updateClassValues(this.value);
        });

        // Familiar toggle functionality
        document.addEventListener('click', function(e) {
            if (e.target.id === 'familiarToggle' || e.target.closest('#familiarToggle')) {
                toggleFamiliarSection();
            }
            // Handle familiar resource box clicks
            if (e.target.dataset.familiarResource) {
                handleFamiliarResourceClick(e.target);
            }
            // Companion toggle functionality
            if (e.target.id === 'companionToggle' || e.target.closest('#companionToggle')) {
                toggleCompanionSection();
            }
            // Handle companion resource box clicks
            if (e.target.dataset.companionResource) {
                handleCompanionResourceClick(e.target);
            }
        });

        function toggleFamiliarSection() {
            const content = document.getElementById('familiarContent');
            const toggleButton = document.getElementById('familiarToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggleButton.innerHTML = '<i class="fas fa-minus text-xs"></i>';
            } else {
                content.style.display = 'none';
                toggleButton.innerHTML = '<i class="fas fa-plus text-xs"></i>';
            }
        }

        function handleFamiliarResourceClick(box) {
            if (!currentCharacter || !currentCharacter.familiar) return;
            
            const resourceType = box.dataset.familiarResource;
            
            if (resourceType === 'hp') {
                // Toggle HP (only 1 box)
                currentCharacter.familiar.hpUsed = !currentCharacter.familiar.hpUsed;
                updateFamiliarDisplay(currentCharacter);
            } else if (resourceType === 'stress') {
                // Toggle stress boxes (2 boxes) with ordering
                if (!currentCharacter.familiar.stressUsed) {
                    currentCharacter.familiar.stressUsed = 0;
                }
                
                const boxId = box.id;
                if (boxId === 'familiarStressBox1') {
                    // If clicking first box
                    if (currentCharacter.familiar.stressUsed === 0) {
                        currentCharacter.familiar.stressUsed = 1; // Mark first box
                    } else {
                        currentCharacter.familiar.stressUsed = 0; // Unmark all
                    }
                } else if (boxId === 'familiarStressBox2') {
                    // If clicking second box
                    if (currentCharacter.familiar.stressUsed < 2) {
                        currentCharacter.familiar.stressUsed = 2; // Mark both boxes
                    } else {
                        currentCharacter.familiar.stressUsed = 1; // Unmark second box only
                    }
                }
                
                updateFamiliarDisplay(currentCharacter);
            }
            
            saveCharacters();
        }

        function updateFamiliarDisplay(character) {
            if (!character) return;
            
            const familiarSection = document.getElementById('familiarSheetSection');
            
            // Show familiar section only if character has a familiar
            if (character.familiar) {
                familiarSection.style.display = 'block';
                
                // Update familiar name
                const nameDisplay = document.getElementById('familiarDisplayName');
                if (nameDisplay) {
                    nameDisplay.textContent = character.familiar.name || 'Familiar';
                }
                
                // Update familiar resource boxes
                const hpBox = document.getElementById('familiarHpBox');
                const stressBox1 = document.getElementById('familiarStressBox1');
                const stressBox2 = document.getElementById('familiarStressBox2');
                
                if (hpBox) {
                    if (character.familiar.hpUsed) {
                        hpBox.classList.add('used');
                    } else {
                        hpBox.classList.remove('used');
                    }
                }
                
                if (stressBox1 && stressBox2) {
                    const stressUsed = character.familiar.stressUsed || 0;
                    
                    if (stressUsed >= 1) {
                        stressBox1.classList.add('used');
                    } else {
                        stressBox1.classList.remove('used');
                    }
                    
                    if (stressUsed >= 2) {
                        stressBox2.classList.add('used');
                    } else {
                        stressBox2.classList.remove('used');
                    }
                }
            } else {
                familiarSection.style.display = 'none';
            }
        }

        function toggleCompanionSection() {
            const content = document.getElementById('companionContent');
            const toggleButton = document.getElementById('companionToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggleButton.innerHTML = '<i class="fas fa-minus text-xs"></i>';
            } else {
                content.style.display = 'none';
                toggleButton.innerHTML = '<i class="fas fa-plus text-xs"></i>';
            }
        }

        function handleCompanionResourceClick(box) {
            if (!currentCharacter || !currentCharacter.companion) return;
            
            const resourceType = box.dataset.companionResource;
            const boxId = box.id;
            
            if (resourceType === 'hp') {
                const hpIndex = parseInt(boxId.replace('companionHpBox', '')) - 1;
                toggleCompanionResourceOrdered(hpIndex, 'hp');
            } else if (resourceType === 'stress') {
                const stressIndex = parseInt(boxId.replace('companionStressBox', '')) - 1;
                toggleCompanionResourceOrdered(stressIndex, 'stress');
            }
            
            saveCharacters();
        }

        function toggleCompanionResourceOrdered(clickedIndex, resourceType) {
            if (!currentCharacter || !currentCharacter.companion) return;
            
            // Initialize arrays if not present
            if (!currentCharacter.companion.hpUsed) {
                currentCharacter.companion.hpUsed = [];
            }
            if (!currentCharacter.companion.stressUsed) {
                currentCharacter.companion.stressUsed = [];
            }
            
            const usedArray = resourceType === 'hp' ? currentCharacter.companion.hpUsed : currentCharacter.companion.stressUsed;
            const isCurrentlyUsed = usedArray.includes(clickedIndex);
            
            if (!isCurrentlyUsed) {
                // Mark as used - fill from left to clicked index (left to right)
                for (let i = 0; i <= clickedIndex; i++) {
                    if (!usedArray.includes(i)) {
                        usedArray.push(i);
                    }
                }
            } else {
                // Unmark as used - unfill from clicked index to the right (right to left)
                for (let i = clickedIndex; i < 10; i++) { // 10 is safe upper bound
                    const indexInArray = usedArray.indexOf(i);
                    if (indexInArray > -1) {
                        usedArray.splice(indexInArray, 1);
                    }
                }
            }
            
            // Update display
            updateCompanionDisplay(currentCharacter);
        }

        function updateCompanionDisplay(character) {
            if (!character) return;
            
            const companionSection = document.getElementById('companionSheetSection');
            
            // Show companion section only if character has a companion
            if (character.companion) {
                companionSection.style.display = 'block';
                
                // Update companion name and type
                const nameDisplay = document.getElementById('companionDisplayName');
                const typeDisplay = document.getElementById('companionDisplayType');
                
                if (nameDisplay) {
                    nameDisplay.textContent = character.companion.name || 'Companion';
                }
                
                if (typeDisplay) {
                    typeDisplay.textContent = character.companion.type || 'Bear';
                }
                
                // Get companion type data
                const companionData = companionTypes[character.companion.type] || companionTypes['Bear'];
                
                // Update the entire companion content with new layout
                const companionContent = document.getElementById('companionContent');
                companionContent.innerHTML = `
                    <!-- Row 1: Name -->
                    <div class="text-center font-medium mb-2">${character.companion.name || 'Companion'}</div>
                    
                    <!-- Row 2: Type -->
                    <div class="text-center text-sm text-gray-600 dark:text-gray-400 mb-3">${character.companion.type || 'Bear'}</div>
                    
                    <!-- Row 3: HP and Stress -->
                    <div class="flex justify-center gap-6 mb-3">
                        <div class="flex flex-col items-center">
                            <div class="text-xs font-medium mb-1">HP</div>
                            <div class="flex gap-1" id="companionHpBoxes">
                                <!-- HP boxes will be generated here -->
                            </div>
                        </div>
                        
                        <div class="flex flex-col items-center">
                            <div class="text-xs font-medium mb-1">Stress</div>
                            <div class="flex gap-1" id="companionStressBoxes">
                                <!-- Stress boxes will be generated here -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Row 4: Stats -->
                    <div class="flex justify-between items-center text-xs">
                        <div class="flex flex-col items-center">
                            <div class="text-xs font-medium mb-1">Evasion</div>
                            <div class="text-sm font-medium">${companionData.evasion}</div>
                        </div>
                        
                        <div class="flex flex-col items-center">
                            <div class="text-xs font-medium mb-1">Mod</div>
                            <div class="text-sm font-medium">+${companionData.mod}</div>
                        </div>
                        
                        <div class="flex flex-col items-center">
                            <div class="text-xs font-medium mb-1">Damage</div>
                            <div class="text-sm font-medium">${companionData.damage}</div>
                        </div>
                        
                        <div class="flex flex-col items-center">
                            <div class="text-xs font-medium mb-1">Threshold</div>
                            <div class="text-sm font-medium">${companionData.thresholdLower} / ${companionData.thresholdUpper}</div>
                        </div>
                    </div>
                `;
                
                // Now populate the HP and Stress boxes in their new containers
                const hpContainer = document.getElementById('companionHpBoxes');
                const stressContainer = document.getElementById('companionStressBoxes');
                
                // Update HP boxes
                for (let i = 0; i < companionData.hp; i++) {
                    const box = document.createElement('div');
                    box.className = 'resource-box solid cursor-pointer';
                    box.id = `companionHpBox${i + 1}`;
                    box.dataset.companionResource = 'hp';
                    
                    if (character.companion.hpUsed && character.companion.hpUsed.includes(i)) {
                        box.classList.add('used');
                    }
                    
                    hpContainer.appendChild(box);
                }
                
                // Update Stress boxes
                for (let i = 0; i < companionData.stress; i++) {
                    const box = document.createElement('div');
                    box.className = 'resource-box solid cursor-pointer';
                    box.id = `companionStressBox${i + 1}`;
                    box.dataset.companionResource = 'stress';
                    
                    if (character.companion.stressUsed && character.companion.stressUsed.includes(i)) {
                        box.classList.add('used');
                    }
                    
                    stressContainer.appendChild(box);
                }
            } else {
                companionSection.style.display = 'none';
            }
        }

        // Character form submission
        document.getElementById('characterForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            // Check if all modifiers are assigned
            const unassigned = Object.values(selectedModifiers).some(mod => mod === null);
            if (unassigned) {
                showCustomDialog('Incomplete Character', 'Please assign all ability score modifiers before creating the character.');
                return;
            }
            
            const characterClass = document.getElementById('charClass').value;
            const normalEvasion = parseInt(document.getElementById('evasion').value);
            
            // Calculate Unarmored Defense evasion for Barbarian and Monk
            let unarmoredDefenseEvasion = normalEvasion;
            let hasUnarmoredDefense = false;
            
            if (characterClass === 'Barbarian' || characterClass === 'Monk') {
                hasUnarmoredDefense = true;
                const initialDexMod = selectedModifiers.dex + (abilityScoreAllocations.dex || 0);
                unarmoredDefenseEvasion = normalEvasion + initialDexMod;
            }
            
            // Handle familiar data for Wizard and Warlock
            let familiarData = null;
            if ((characterClass === 'Wizard' || characterClass === 'Warlock') && document.getElementById('hasFamiliar').checked) {
                const familiarName = document.getElementById('familiarName').value.trim() || 'Familiar';
                familiarData = {
                    name: familiarName,
                    hpUsed: false,
                    stressUsed: 0 // 0 = none, 1 = first box, 2 = both boxes
                };
            }

            // Handle companion data for Ranger
            let companionData = null;
            if (characterClass === 'Ranger' && document.getElementById('hasCompanion').checked) {
                const companionName = document.getElementById('companionName').value.trim() || 'Companion';
                const companionType = document.getElementById('companionType').value || 'Bear';
                companionData = {
                    name: companionName,
                    type: companionType,
                    hpUsed: [], // Array of used HP box indices
                    stressUsed: [] // Array of used Stress box indices
                };
            }

            const character = {
                id: Date.now().toString(),
                name: document.getElementById('charName').value,
                level: parseInt(document.getElementById('charLevel').value),
                race: document.getElementById('charRace').value,
                class: characterClass,
                str: selectedModifiers.str,
                dex: selectedModifiers.dex,
                con: selectedModifiers.con,
                int: selectedModifiers.int,
                wis: selectedModifiers.wis,
                cha: selectedModifiers.cha,
                // Store initial ability scores for Unarmored Defense
                initialDex: selectedModifiers.dex + (abilityScoreAllocations.dex || 0),
                initialCon: selectedModifiers.con + (abilityScoreAllocations.con || 0),
                proficiencies: { ...proficiencies },
                abilityScoreAllocations: { ...abilityScoreAllocations },
                // Store initial modifiers for Unarmored Defense (including racial bonuses)
                initialModifiers: {
                    dex: selectedModifiers.dex + (abilityScoreAllocations.dex || 0),
                    con: selectedModifiers.con + (abilityScoreAllocations.con || 0)
                },
                hpMax: parseInt(document.getElementById('hpMax').value),
                stressMax: parseInt(document.getElementById('stressMax').value),
                classMax: parseInt(document.getElementById('classMax').value),
                spellMax: parseInt(document.getElementById('spellMax').value),
                resources: {
                    hp: { max: parseInt(document.getElementById('hpMax').value), used: [], temp: 0 },
                    stress: { max: parseInt(document.getElementById('stressMax').value), used: [], temp: 0 },
                    class: { max: parseInt(document.getElementById('classMax').value), used: [], temp: 0 },
                    spell: { max: parseInt(document.getElementById('spellMax').value), used: [], temp: 0 }
                },
                // Store both evasion values for Unarmored Defense classes
                evasion: normalEvasion,
                normalEvasion: normalEvasion,
                unarmoredDefenseEvasion: unarmoredDefenseEvasion,
                hasUnarmoredDefense: hasUnarmoredDefense,
                unarmoredDefenseActive: false, // Default to normal evasion
                armor: parseInt(document.getElementById('armor').value),
                armorSlots: { 
                    total: parseInt(document.getElementById('armor').value), 
                    filled: [],
                    permanent: parseInt(document.getElementById('armor').value),
                    temporary: 0
                },
                thresholdLower: parseInt(document.getElementById('thresholdLower').value),
                thresholdUpper: parseInt(document.getElementById('thresholdUpper').value),
                equipment: [],
                notes: '',
                // Store race selections
                selectedRaceBonuses: [...selectedRaceBonuses],
                selectedRaceProficiencies: [...selectedRaceProficiencies],
                selectedAbilityScores: [...selectedAbilityScores],
                raceBonusValues: { ...raceBonusValues },
                // Store familiar data
                familiar: familiarData,
                // Store companion data
                companion: companionData,
                // Initialize weapon and armor properties
                primaryWeapon: null,
                secondaryWeapon: null,
                armorItem: null,
                primaryWeaponBonuses: {},
                secondaryWeaponBonuses: {},
                armorBonuses: {},
                primaryWeaponAbilityBonuses: { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 },
                secondaryWeaponAbilityBonuses: { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 },
                armorAbilityBonuses: { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 },
                // Initialize weapon proficiency (starts with 1 circle filled at level 1)
                weaponProficiency: 1
            };
            
            characters.push(character);
            saveCharacters();
            updateCharacterDisplay();
            showCharacterList();
        });
        
        // Ability selector event listeners
        document.querySelectorAll('.ability-selector').forEach(selector => {
            selector.addEventListener('click', function() {
                const ability = this.dataset.ability;
                showModifierSelection(ability);
            });
        });
        
        // Proficiency circle event listeners removed for character creation
           // Proficiency circle event listeners
        document.querySelectorAll('.weapon-proficiency-circle').forEach(circle => {
            circle.addEventListener('click', function() {
                const ability = this.dataset.ability;
                toggleProficiency(ability);
            });
        });
        
        // Sheet proficiency circle event listeners
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('stat-proficiency')) {
                const ability = e.target.dataset.ability;
                toggleSheetProficiency(ability);
            }
        });
        
        // Combat stat box click listeners - Enhanced for armor slots and evasion
        document.addEventListener('click', function(e) {
            if (e.target.id === 'displayArmor' || e.target.closest('#armorCircles')) {
                if (e.target.id === 'displayArmor') {
                    showArmorSlotsModal();
                }
            } else if (e.target.id === 'displayEvasion') {
                showEvasionModal();
            }
        });
        
        // Reset modifiers button
        document.getElementById('resetModifiers').addEventListener('click', function() {
            resetModifierSystem();
            // Don't reset proficiency system - preserve race-selected proficiencies
        });

        // Randomize modifiers button
        document.getElementById('randomizeModifiers').addEventListener('click', function() {
            randomizeModifiers();
        });
        
        function randomizeModifiers() {
            // Reset current selections
            selectedModifiers = { str: null, dex: null, con: null, int: null, wis: null, cha: null };
            usedModifiers = [];
            
            // Create a shuffled copy of available modifiers
            const shuffledModifiers = [...availableModifiers];
            for (let i = shuffledModifiers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledModifiers[i], shuffledModifiers[j]] = [shuffledModifiers[j], shuffledModifiers[i]];
            }
            
            // Assign modifiers to abilities randomly
            const abilities = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
            for (let i = 0; i < abilities.length; i++) {
                selectedModifiers[abilities[i]] = shuffledModifiers[i];
                usedModifiers.push(i);
            }
            
            // Update displays
            updateAvailableModifiers();
            updateAbilitySelectors();
        }

        // Weapon/armor modal event listeners
        document.addEventListener('click', function(e) {
            if (e.target.id === 'addPrimaryWeapon') {
                showWeaponModal('primary');
            } else if (e.target.id === 'addSecondaryWeapon') {
                showWeaponModal('secondary');
            } else if (e.target.id === 'addArmor') {
                showWeaponModal('armor');
            }
        });

        document.getElementById('cancelWeapon').addEventListener('click', function() {
            document.getElementById('weaponModal').classList.add('hidden');
        });

        document.getElementById('confirmWeapon').addEventListener('click', function() {
            if (selectedWeapon || selectedArmor) {
                addWeaponToCharacter();
            } else {
                showCustomDialog('No Selection', 'Please select an item first.');
            }
        });

        document.getElementById('cancelWeaponRemoval').addEventListener('click', function() {
            document.getElementById('weaponRemovalModal').classList.add('hidden');
        });

        document.getElementById('confirmWeaponRemoval').addEventListener('click', function() {
            removeWeapon();
        });

        // New Ability Score Modal Event Listeners
        document.getElementById('cancelAbilityScoreNew').addEventListener('click', function() {
            document.getElementById('abilityScoreModal').classList.add('hidden');
        });



        // FIXED FUNCTION: Proper allocation logic for multi-options
        document.getElementById('confirmAbilityScoreNew').addEventListener('click', function() {
            const modal = document.getElementById('abilityScoreModal');
            const selectedCheckboxes = modal.querySelectorAll('.ability-checkbox.selected');
            
            let allocations = { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            let hasPositiveMulti = false;
            let hasNegativeMulti = false;
            let selectedPositiveAbilities = [];
            let selectedNegativeAbilities = [];
            
            const initialPositive = parseInt(modal.dataset.initialPositivePoints);
            const initialNegative = parseInt(modal.dataset.initialNegativePoints);
            
            // First pass: collect all selections
            selectedCheckboxes.forEach(checkbox => {
                const type = checkbox.dataset.type;
                const ability = checkbox.dataset.ability;
                
                if (type === 'positive-multi') {
                    hasPositiveMulti = true;
                } else if (type === 'negative-multi') {
                    hasNegativeMulti = true;
                } else if (type === 'positive') {
                    selectedPositiveAbilities.push(ability);
                } else if (type === 'negative') {
                    selectedNegativeAbilities.push(ability);
                }
            });
            
            // Second pass: allocate points
            if (hasPositiveMulti && selectedPositiveAbilities.length === 1) {
                // Apply all positive points to the one selected ability
                allocations[selectedPositiveAbilities[0]] += initialPositive;
            } else if (!hasPositiveMulti) {
                // Normal allocation of 1 point per selected ability
                selectedPositiveAbilities.forEach(ability => {
                    allocations[ability] += 1;
                });
            }
            
            if (hasNegativeMulti && selectedNegativeAbilities.length === 1) {
                // Apply all negative points to the one selected ability
                allocations[selectedNegativeAbilities[0]] -= initialNegative;
            } else if (!hasNegativeMulti) {
                // Normal allocation of -1 point per selected ability
                selectedNegativeAbilities.forEach(ability => {
                    allocations[ability] -= 1;
                });
            }
            
            // Validate allocation matches available points
            let allocatedPositive = 0;
            let allocatedNegative = 0;
            
            Object.values(allocations).forEach(value => {
                if (value > 0) allocatedPositive += value;
                if (value < 0) allocatedNegative += Math.abs(value);
            });
            
            // Check for invalid multi-option usage
            if (hasPositiveMulti && selectedPositiveAbilities.length !== 1) {
                showCustomDialog('Invalid Selection', 'When using "Apply all positive points to one ability score", you must select exactly one positive ability.');
                return;
            }
            
            if (hasNegativeMulti && selectedNegativeAbilities.length !== 1) {
                showCustomDialog('Invalid Selection', 'When using "Apply all negative points to one ability score", you must select exactly one negative ability.');
                return;
            }
            
            if (allocatedPositive !== initialPositive || allocatedNegative !== initialNegative) {
                showCustomDialog('Invalid Allocation', 'You must allocate all available points.');
                return;
            }
            
            // Apply the allocations
            abilityScoreAllocations = allocations;
            updateAbilityScoreResults();
            updateLiveAbilityScores();
            
            modal.classList.add('hidden');
        });

        // Ability checkbox click handler
        document.addEventListener('click', function(e) {
            if (e.target.closest('.ability-checkbox')) {
                const checkbox = e.target.closest('.ability-checkbox');
                const input = checkbox.querySelector('input');
                const type = checkbox.dataset.type;
                
                // Toggle selection
                if (checkbox.classList.contains('selected')) {
                    checkbox.classList.remove('selected');
                    input.checked = false;
                } else {
                    // Handle multi-option logic
                    if (type === 'positive-multi' || type === 'negative-multi') {
                        // Unselect other multi options in the same category
                        const categoryPrefix = type.split('-')[0];
                        document.querySelectorAll(`.ability-checkbox[data-type^="${categoryPrefix}-multi"]`).forEach(cb => {
                            if (cb !== checkbox) {
                                cb.classList.remove('selected');
                                cb.querySelector('input').checked = false;
                            }
                        });
                    }
                    
                    checkbox.classList.add('selected');
                    input.checked = true;
                }
                
                // Update points counter
                updateAbilityScorePointsCounter();
            }
        });

        function updateAbilityScorePointsCounter() {
            const modal = document.getElementById('abilityScoreModal');
            const initialPositive = parseInt(modal.dataset.initialPositivePoints);
            const initialNegative = parseInt(modal.dataset.initialNegativePoints);
            
            let allocatedPositive = 0;
            let allocatedNegative = 0;
            let hasPositiveMulti = false;
            let hasNegativeMulti = false;
            
            // Count allocated points
            modal.querySelectorAll('.ability-checkbox.selected').forEach(checkbox => {
                const type = checkbox.dataset.type;
                
                if (type === 'positive') {
                    allocatedPositive += hasPositiveMulti ? 0 : 1;
                } else if (type === 'negative') {
                    allocatedNegative += hasNegativeMulti ? 0 : 1;
                } else if (type === 'positive-multi') {
                    hasPositiveMulti = true;
                    allocatedPositive = initialPositive; // Multi takes all points
                } else if (type === 'negative-multi') {
                    hasNegativeMulti = true;
                    allocatedNegative = initialNegative; // Multi takes all points
                }
            });
            
            document.getElementById('positivePointsRemaining').textContent = initialPositive - allocatedPositive;
            document.getElementById('negativePointsRemaining').textContent = initialNegative - allocatedNegative;
        }

        // Temp Points Modal Event Listeners
        document.getElementById('cancelTempPoints').addEventListener('click', function() {
            document.getElementById('tempPointsModal').classList.add('hidden');
        });

        document.getElementById('addTempPoints').addEventListener('click', function() {
            const modal = document.getElementById('tempPointsModal');
            const amount = parseInt(document.getElementById('tempPointsAmount').value);
            const resourceType = modal.dataset.resourceType;
            
            if (amount && amount > 0) {
                addTempPoints(resourceType, amount);
            }
            
            modal.classList.add('hidden');
        });

        document.getElementById('removeTempPoints').addEventListener('click', function() {
            const modal = document.getElementById('tempPointsModal');
            const amount = parseInt(document.getElementById('tempPointsAmount').value);
            const resourceType = modal.dataset.resourceType;
            
            if (amount && amount > 0) {
                removeTempResourcePoints(resourceType, amount);
            } else {
                showCustomDialog('Invalid Amount', 'Please enter a valid amount to remove.');
                return;
            }
            
            modal.classList.add('hidden');
        });

        // Allow Enter key to confirm temp points
        document.getElementById('tempPointsAmount').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                document.getElementById('confirmTempPoints').click();
            }
        });

        // Enhanced Armor Slots Modal Event Listeners
        document.getElementById('cancelArmorSlots').addEventListener('click', function() {
            document.getElementById('armorSlotsModal').classList.add('hidden');
        });

        document.getElementById('addArmorSlots').addEventListener('click', function() {
            const amount = parseInt(document.getElementById('armorSlotsAmount').value);
            if (amount && amount > 0) {
                adjustArmorSlots(amount, true);
            }
        });

        document.getElementById('removeArmorSlots').addEventListener('click', function() {
            const amount = parseInt(document.getElementById('armorSlotsAmount').value);
            if (amount && amount > 0) {
                adjustArmorSlots(amount, false);
            }
        });

        // Allow Enter key to focus on Add button for armor slots
        document.getElementById('armorSlotsAmount').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                document.getElementById('addArmorSlots').focus();
            }
        });

        // Health Potions Functions
        function generateHealthPotionCircles(character) {
            const container = document.getElementById('healthPotionCircles');
            container.innerHTML = '';
            
            // Initialize health potions array if not present
            if (!character.healthPotions) {
                character.healthPotions = [false, false, false, false];
            }
            
            for (let i = 0; i < 4; i++) {
                const circle = document.createElement('div');
                circle.className = 'w-5 h-5 rounded-full border-2 border-red-400 cursor-pointer transition-all hover:border-red-600';
                circle.dataset.index = i;
                
                // Set filled state
                if (character.healthPotions[i]) {
                    circle.classList.add('bg-red-500');
                } else {
                    circle.classList.add('bg-transparent');
                }
                
                circle.addEventListener('click', function() {
                    toggleHealthPotion(parseInt(this.dataset.index));
                });
                
                container.appendChild(circle);
            }
        }
        
        function toggleHealthPotion(index) {
            if (!currentCharacter) return;
            
            if (!currentCharacter.healthPotions) {
                currentCharacter.healthPotions = [false, false, false, false];
            }
            
            // Toggle the potion state
            currentCharacter.healthPotions[index] = !currentCharacter.healthPotions[index];
            
            // Regenerate circles to update display
            generateHealthPotionCircles(currentCharacter);
            saveCharacters();
        }
        
        function useHealthPotion() {
            if (!currentCharacter) return;
            
            if (!currentCharacter.healthPotions) {
                currentCharacter.healthPotions = [false, false, false, false];
            }
            
            // Check if there are any health potions available
            const availablePotionIndex = currentCharacter.healthPotions.findIndex(potion => potion === true);
            if (availablePotionIndex === -1) {
                showCustomDialog('No Health Potions', 'You have no health potions available to use.');
                return;
            }
            
            // Roll 1d6
            const roll = Math.floor(Math.random() * 6) + 1;
            
            // Remove one health potion (unfill the first available one)
            currentCharacter.healthPotions[availablePotionIndex] = false;
            
            // Restore HP by removing 'roll' amount of used HP boxes
            if (!currentCharacter.resources || !currentCharacter.resources.hp) {
                showCustomDialog('No HP to Restore', 'Character has no HP resource to restore.');
                generateHealthPotionCircles(currentCharacter);
                saveCharacters();
                return;
            }
            
            const hpResource = currentCharacter.resources.hp;
            const usedBoxes = [...hpResource.used].sort((a, b) => b - a); // Sort descending to remove from highest indices first
            
            let pointsRestored = 0;
            
            // Remove used HP boxes starting from the highest indices
            for (let i = 0; i < usedBoxes.length && pointsRestored < roll; i++) {
                const index = usedBoxes[i];
                const indexPosition = hpResource.used.indexOf(index);
                if (indexPosition !== -1) {
                    hpResource.used.splice(indexPosition, 1);
                    pointsRestored++;
                }
            }
            
            // Update displays
            generateHealthPotionCircles(currentCharacter);
            populateSheetResourceBoxes(currentCharacter);
            saveCharacters();
            
            // Show result message
            const message = `Used health potion! Rolled ${roll} and restored ${pointsRestored} HP.`;
            showCustomDialog('Health Potion Used', message);
        }
        
        // Health Potion button event listener
        document.addEventListener('click', function(e) {
            if (e.target.id === 'useHealthPotion' || e.target.closest('#useHealthPotion')) {
                useHealthPotion();
            }
        });

        // Evasion Modal Event Listeners
        document.getElementById('cancelEvasion').addEventListener('click', function() {
            document.getElementById('evasionModal').classList.add('hidden');
        });

        document.getElementById('addTempEvasion').addEventListener('click', function() {
            const amount = parseInt(document.getElementById('evasionAmount').value);
            if (amount && amount > 0) {
                addTempEvasion(amount);
            }
        });

        document.getElementById('adjustBaseEvasion').addEventListener('click', function() {
            const amount = parseInt(document.getElementById('evasionAmount').value);
            if (amount) {
                adjustBaseEvasion(amount);
            }
        });

        document.getElementById('resetTempEvasion').addEventListener('click', function() {
            resetTempEvasion();
        });

        // Allow Enter key to focus on Add Temp button for evasion
        document.getElementById('evasionAmount').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                document.getElementById('addTempEvasion').focus();
            }
        });

        // Evasion Modal Functions
        function showEvasionModal() {
            if (!currentCharacter) return;
            
            const modal = document.getElementById('evasionModal');
            
            // Initialize simplified evasion data if missing
            if (!currentCharacter.evasionData) {
                currentCharacter.evasionData = {
                    base: currentCharacter.evasion || 0,
                    temporary: 0,
                    unarmoredDefense: 0,
                    mageArmor: 0
                };
            }
            
            // Get armor evasion value
            const armorEvasion = getArmorEvasionValue(currentCharacter);
            
            // Calculate current total evasion
            const currentEvasion = getCurrentEvasion(currentCharacter);
            
            // Update modal display
            document.getElementById('currentEvasion').textContent = currentEvasion;
            document.getElementById('baseEvasion').textContent = currentCharacter.evasionData.base || 0;
            document.getElementById('temporaryEvasion').textContent = currentCharacter.evasionData.temporary || 0;
            document.getElementById('armorEvasion').textContent = armorEvasion;
            
            document.getElementById('evasionAmount').value = '';
            modal.classList.remove('hidden');
            document.getElementById('evasionAmount').focus();
        }
        
        function getArmorEvasionValue(character) {
            if (!character.armorItem) return 0;
            
            // Get the evasion bonus from armor (can be negative)
            return character.armorItem.bonuses?.evasion || 0;
        }
        
        function getCurrentEvasion(character) {
            if (!character.evasionData) {
                character.evasionData = {
                    base: character.evasion || 0,
                    temporary: 0,
                    unarmoredDefense: 0,
                    mageArmor: 0
                };
            }
            
            const baseEvasion = character.evasionData.base || 0;
            const tempEvasion = character.evasionData.temporary || 0;
            const unarmoredDefenseEvasion = character.evasionData.unarmoredDefense || 0;
            const mageArmorEvasion = character.evasionData.mageArmor || 0;
            const armorEvasion = getArmorEvasionValue(character);
            
            return baseEvasion + tempEvasion + unarmoredDefenseEvasion + mageArmorEvasion + armorEvasion;
        }
        
        function calculateTotalEvasion(character) {
            if (!character.evasionData) {
                character.evasionData = {
                    base: character.evasion || 0,
                    temporary: 0
                };
            }
            
            const baseEvasion = character.evasionData.base || 0;
            const tempEvasion = character.evasionData.temporary || 0;
            const armorEvasion = getArmorEvasionValue(character);
            
            return baseEvasion + tempEvasion + armorEvasion;
        }
        
        function getMinimumEvasionValue(character) {
            const armorEvasion = getArmorEvasionValue(character);
            // Minimum evasion is 1, but if armor provides evasion bonus, use that as minimum
            return Math.max(1, armorEvasion);
        }
        
        function updateLevelUpButtonState(character) {
            if (!character) return;
            
            const levelUpBtn = document.getElementById('levelUpCharacter');
            if (!levelUpBtn) return;
            
            // Check if character is at max level (10)
            if (character.level >= 10) {
                levelUpBtn.disabled = true;
                levelUpBtn.classList.add('opacity-50', 'cursor-not-allowed');
                levelUpBtn.classList.remove('hover:bg-green-600');
            } else {
                levelUpBtn.disabled = false;
                levelUpBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                levelUpBtn.classList.add('hover:bg-green-600');
            }
        }

        function updateCharacterEvasion() {
            if (!currentCharacter) return;
            
            // Initialize simplified evasion data if missing
            if (!currentCharacter.evasionData) {
                currentCharacter.evasionData = {
                    base: currentCharacter.evasion || 0,
                    temporary: 0,
                    unarmoredDefense: 0,
                    mageArmor: 0
                };
            }
            
            // Update character's main evasion value
            currentCharacter.evasion = getCurrentEvasion(currentCharacter);
            
            // Update display
            const evasionDisplay = document.getElementById('displayEvasion');
            if (evasionDisplay) {
                evasionDisplay.textContent = currentCharacter.evasion;
            }
        }

        function addTempEvasion(amount) {
            if (!currentCharacter || !amount || amount < 1) return;
            
            // Initialize evasion data if missing
            if (!currentCharacter.evasionData) {
                currentCharacter.evasionData = {
                    base: currentCharacter.evasion || 0,
                    temporary: 0,
                    unarmoredDefense: 0,
                    mageArmor: 0
                };
            }
            
            // Add temporary evasion
            currentCharacter.evasionData.temporary = (currentCharacter.evasionData.temporary || 0) + amount;
            
            // Update the character's main evasion value
            currentCharacter.evasion = getCurrentEvasion(currentCharacter);
            
            saveCharacters();
            populateCharacterSheet(currentCharacter);
            
            document.getElementById('evasionModal').classList.add('hidden');
        }
        
        function adjustBaseEvasion(amount) {
            if (!currentCharacter || !amount) return;
            
            // Initialize evasion data if missing
            if (!currentCharacter.evasionData) {
                currentCharacter.evasionData = {
                    base: currentCharacter.evasion || 0,
                    temporary: 0,
                    unarmoredDefense: 0,
                    mageArmor: 0
                };
            }
            
            // Get minimum evasion value (1 or armor's evasion value, whichever is higher)
            const minimumEvasion = getMinimumEvasionValue(currentCharacter);
            const newBaseEvasion = (currentCharacter.evasionData.base || 0) + amount;
            
            // Check if the new value would go below the minimum
            if (newBaseEvasion < minimumEvasion) {
                const armorEvasion = getArmorEvasionValue(currentCharacter);
                if (armorEvasion > 1) {
                    showCustomDialog('Evasion Restriction', `Sorry, you can't go below your Armor's Value of ${armorEvasion}.`);
                } else {
                    showCustomDialog('Evasion Restriction', "Sorry, you can't go below your Armor's Value. Evasion cannot drop below 1.");
                }
                document.getElementById('evasionModal').classList.add('hidden');
                return;
            }
            
            // Adjust base evasion
            currentCharacter.evasionData.base = newBaseEvasion;
            
            // Update the character's main evasion value
            currentCharacter.evasion = getCurrentEvasion(currentCharacter);
            
            saveCharacters();
            populateCharacterSheet(currentCharacter);
            
            document.getElementById('evasionModal').classList.add('hidden');
        }
        
        function resetTempEvasion() {
            if (!currentCharacter) return;
            
            // Initialize evasion data if missing
            if (!currentCharacter.evasionData) {
                currentCharacter.evasionData = {
                    base: currentCharacter.evasion || 0,
                    temporary: 0,
                    unarmoredDefense: 0,
                    mageArmor: 0
                };
            }
            
            // Reset temporary evasion only
            currentCharacter.evasionData.temporary = 0;
            
            // Update the character's main evasion value
            currentCharacter.evasion = getCurrentEvasion(currentCharacter);
            
            saveCharacters();
            populateCharacterSheet(currentCharacter);
            
            document.getElementById('evasionModal').classList.add('hidden');
        }

        // Helper function to calculate effective threshold values (including Unarmored Defense)
        function getEffectiveThresholdValues(character) {
            const thresholdLowerBase = character.thresholdLower || 0;
            const thresholdUpperBase = character.thresholdUpper || 0;
            
            let thresholdLowerEffective = thresholdLowerBase;
            let thresholdUpperEffective = thresholdUpperBase;
            
            // Apply Unarmored Defense threshold bonuses if active (allow ceremonial Unarmored Defense armor)
            if (character.unarmoredDefenseActive && (!character.armorItem || character.armorItem.isUnarmoredDefense)) {
                if (character.class === 'Monk') {
                    const currentDex = getCurrentDexModifier(character);
                    thresholdLowerEffective += currentDex;
                    thresholdUpperEffective += currentDex;
                } else if (character.class === 'Barbarian') {
                    const currentDex = getCurrentDexModifier(character);
                    const currentCon = getCurrentConModifier(character);
                    thresholdLowerEffective += currentDex;
                    thresholdUpperEffective += currentDex + currentCon;
                }
                
                // Add level-up bonuses for Barbarians and Monks
                if (character.unarmoredDefenseThresholdBonuses) {
                    thresholdLowerEffective += character.unarmoredDefenseThresholdBonuses.lower || 0;
                    thresholdUpperEffective += character.unarmoredDefenseThresholdBonuses.upper || 0;
                }
            }
            
            return {
                lower: thresholdLowerEffective,
                upper: thresholdUpperEffective
            };
        }

        // Threshold temp box functions
        function updateThresholdTempBoxes(character) {
            if (!character.tempThreshold) {
                character.tempThreshold = { lower: 0, upper: 0 };
            }
            
            // Get effective threshold values (including Unarmored Defense)
            const effectiveThreshold = getEffectiveThresholdValues(character);
            
            const lowerValue = effectiveThreshold.lower + character.tempThreshold.lower;
            const upperValue = effectiveThreshold.upper + character.tempThreshold.upper;
            
            // Update lower temp boxes
            document.getElementById('thresholdLowerTemp1').textContent = character.tempThreshold.lower > 0 ? lowerValue : '-';
           
            
            // Update upper temp boxes
            document.getElementById('thresholdUpperTemp1').textContent = character.tempThreshold.upper > 0 ? upperValue : '-';
        }
        
        function showTempThresholdModal() {
            const modal = document.getElementById('tempThresholdModal');
            document.getElementById('tempThresholdLower').value = '';
            document.getElementById('tempThresholdUpper').value = '';
            modal.classList.remove('hidden');
            document.getElementById('tempThresholdLower').focus();
        }
        
        function addTempThreshold() {
            if (!currentCharacter) return;
            
            const lowerTemp = parseInt(document.getElementById('tempThresholdLower').value) || 0;
            const upperTemp = parseInt(document.getElementById('tempThresholdUpper').value) || 0;
            
            if (!currentCharacter.tempThreshold) {
                currentCharacter.tempThreshold = { lower: 0, upper: 0 };
            }
            
            currentCharacter.tempThreshold.lower += lowerTemp;
            currentCharacter.tempThreshold.upper += upperTemp;
            
            updateThresholdTempBoxes(currentCharacter);
            saveCharacters();
            
            document.getElementById('tempThresholdModal').classList.add('hidden');
        }
        
        function resetTempThreshold() {
            if (!currentCharacter) return;
            
            currentCharacter.tempThreshold = { lower: 0, upper: 0 };
            updateThresholdTempBoxes(currentCharacter);
            saveCharacters();
            
            // Clear the modal inputs
            document.getElementById('tempThresholdLower').value = '';
            document.getElementById('tempThresholdUpper').value = '';
        }

        // Notes saving
        document.getElementById('characterNotes').addEventListener('blur', function() {
            if (currentCharacter) {
                currentCharacter.notes = this.value;
                saveCharacters();
            }
        });
        
        // Unarmored Defense and Mage Armor toggles
        document.addEventListener('change', function(e) {
            if (e.target.id === 'unarmoredDefenseToggle') {
                handleUnarmoredDefenseToggle(e.target.checked);
            } else if (e.target.id === 'mageArmorToggle') {
                handleMageArmorToggle(e.target.checked);
            }
        });

        // Equipment modal
        document.getElementById('addEquipment').addEventListener('click', function() {
            document.getElementById('equipmentModal').classList.remove('hidden');
        });

        document.getElementById('cancelEquipment').addEventListener('click', function() {
            document.getElementById('equipmentModal').classList.add('hidden');
        });

        document.getElementById('equipmentForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            if (currentCharacter) {
                const item = {
                    name: document.getElementById('equipmentName').value,
                    quantity: parseInt(document.getElementById('equipmentQuantity').value)
                };
                
                if (!currentCharacter.equipment) {
                    currentCharacter.equipment = [];
                }
                
                currentCharacter.equipment.push(item);
                updateEquipmentDisplay(currentCharacter);
                saveCharacters();
                
                document.getElementById('equipmentModal').classList.add('hidden');
                document.getElementById('equipmentForm').reset();
                document.getElementById('equipmentQuantity').value = 1;
            }
        });

        // Temp Threshold Modal Event Listeners
        document.getElementById('cancelTempThreshold').addEventListener('click', function() {
            document.getElementById('tempThresholdModal').classList.add('hidden');
        });

        document.getElementById('confirmTempThreshold').addEventListener('click', function() {
            addTempThreshold();
        });

        document.getElementById('resetTempThreshold').addEventListener('click', function() {
            resetTempThreshold();
        });

        // Add event listeners to threshold temp boxes on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Use event delegation for dynamically created threshold temp boxes
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('threshold-temp-box')) {
                    showTempThresholdModal();
                }
            });
        });

        // Allow Enter key to confirm temp threshold
        document.getElementById('tempThresholdLower').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                document.getElementById('tempThresholdUpper').focus();
            }
        });

        document.getElementById('tempThresholdUpper').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addTempThreshold();
            }
        });

        // Familiar section event listeners
        document.getElementById('hasFamiliar').addEventListener('change', function() {
            const familiarNameSection = document.getElementById('familiarNameSection');
            if (this.checked) {
                familiarNameSection.classList.remove('hidden');
            } else {
                familiarNameSection.classList.add('hidden');
            }
        });

        document.getElementById('editHasFamiliar').addEventListener('change', function() {
            const familiarNameSection = document.getElementById('editFamiliarNameSection');
            if (this.checked) {
                familiarNameSection.classList.remove('hidden');
            } else {
                familiarNameSection.classList.add('hidden');
            }
        });

        // Companion section event listeners
        document.getElementById('hasCompanion').addEventListener('change', function() {
            const companionDetailsSection = document.getElementById('companionDetailsSection');
            if (this.checked) {
                companionDetailsSection.classList.remove('hidden');
            } else {
                companionDetailsSection.classList.add('hidden');
            }
        });

        document.getElementById('editHasCompanion').addEventListener('change', function() {
            const companionDetailsSection = document.getElementById('editCompanionDetailsSection');
            if (this.checked) {
                companionDetailsSection.classList.remove('hidden');
            } else {
                companionDetailsSection.classList.add('hidden');
            }
        });

        // Class selection event listeners for familiar and companion sections
        document.getElementById('charClass').addEventListener('change', function() {
            const familiarSection = document.getElementById('familiarSection');
            const companionSection = document.getElementById('companionSection');
            
            // Handle Familiar section (Wizard/Warlock)
            if (this.value === 'Wizard' || this.value === 'Warlock') {
                familiarSection.style.display = 'block';
            } else {
                familiarSection.style.display = 'none';
                // Reset familiar when class changes away from Wizard/Warlock
                document.getElementById('hasFamiliar').checked = false;
                document.getElementById('familiarNameSection').classList.add('hidden');
                document.getElementById('familiarName').value = '';
            }
            
            // Handle Companion section (Ranger)
            if (this.value === 'Ranger') {
                companionSection.style.display = 'block';
            } else {
                companionSection.style.display = 'none';
                // Reset companion when class changes away from Ranger
                document.getElementById('hasCompanion').checked = false;
                document.getElementById('companionDetailsSection').classList.add('hidden');
                document.getElementById('companionName').value = '';
                document.getElementById('companionType').value = '';
            }
            
            updateClassValues(this.value);
        });

        document.getElementById('editCharClass').addEventListener('change', function() {
            const familiarSection = document.getElementById('editFamiliarSection');
            const companionSection = document.getElementById('editCompanionSection');
            
            // Handle Familiar section (Wizard/Warlock)
            if (this.value === 'Wizard' || this.value === 'Warlock') {
                familiarSection.style.display = 'block';
            } else {
                familiarSection.style.display = 'none';
                // Reset familiar when class changes away from Wizard/Warlock
                document.getElementById('editHasFamiliar').checked = false;
                document.getElementById('editFamiliarNameSection').classList.add('hidden');
                document.getElementById('editFamiliarName').value = '';
            }
            
            // Handle Companion section (Ranger)
            if (this.value === 'Ranger') {
                companionSection.style.display = 'block';
            } else {
                companionSection.style.display = 'none';
                // Reset companion when class changes away from Ranger
                document.getElementById('editHasCompanion').checked = false;
                document.getElementById('editCompanionDetailsSection').classList.add('hidden');
                document.getElementById('editCompanionName').value = '';
                document.getElementById('editCompanionType').value = '';
            }
        });

        // Character Deletion Event Listeners
        document.getElementById('deleteCharacter').addEventListener('click', function() {
            if (!currentCharacter) return;
            showCharacterDeletionModal();
        });

        document.getElementById('cancelCharacterDeletion').addEventListener('click', function() {
            document.getElementById('characterDeletionModal').classList.add('hidden');
        });

        document.getElementById('confirmCharacterDeletion').addEventListener('click', function() {
            deleteCurrentCharacter();
        });

        // Edit Character event listener
        document.getElementById('editCharacterBtn').addEventListener('click', function() {
            if (!currentCharacter) return;
            populateCharacterCreationForm();
        });

        // Individual Character Save/Load Event Listeners
        const saveCharacterBtn = document.getElementById('saveCharacter');
        if (saveCharacterBtn) {
            saveCharacterBtn.addEventListener('click', function() {
                if (!currentCharacter) return;
                saveIndividualCharacter();
            });
        }

        const loadSingleCharacterInput = document.getElementById('loadSingleCharacterInput');
        if (loadSingleCharacterInput) {
            loadSingleCharacterInput.addEventListener('change', function(event) {
                loadSingleCharacterFromFile(event);
            });
        }

        // Character deletion confirmation checkbox handling
        document.getElementById('deleteConfirmationCheckbox').addEventListener('change', function() {
            const confirmButton = document.getElementById('confirmCharacterDeletion');
            if (this.checked) {
                confirmButton.disabled = false;
                confirmButton.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                confirmButton.disabled = true;
                confirmButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
        });

        // Save/Load Characters Event Listeners
        document.getElementById('saveCharactersBtn').addEventListener('click', saveAllCharacters);
        // Intelligent Load Functions
        function intelligentLoad() {
            // Trigger the hidden file input
            document.getElementById('loadFileInput').click();
        }

        function handleIntelligentLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            if (!file.name.endsWith('.json')) {
                showCustomDialog('Invalid File', 'Please select a valid JSON file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Determine file type and handle accordingly
                    if (data.character) {
                        // Single character format
                        handleSingleCharacterLoad(data, file.name);
                    } else if (data.characters && Array.isArray(data.characters)) {
                        if (data.characters.length === 1) {
                            // Single character in array format
                            handleSingleCharacterLoad({ character: data.characters[0], exportDate: data.exportDate }, file.name);
                        } else {
                            // Multiple characters format
                            handleMultipleCharactersLoad(data, file.name);
                        }
                    } else {
                        showCustomDialog('Invalid File Format', 'The selected file does not contain valid character data.');
                        return;
                    }

                } catch (error) {
                    console.error('Error parsing file:', error);
                    showCustomDialog('File Error', 'Failed to read the file. Please ensure it is a valid RPG Character Manager export.');
                }
            };

            reader.readAsText(file);
            
            // Reset the file input so the same file can be selected again
            event.target.value = '';
        }

        function handleSingleCharacterLoad(data, fileName) {
            const characterToImport = data.character;
            
            // Validate character has required properties
            if (!characterToImport.name || !characterToImport.race || !characterToImport.class) {
                showCustomDialog('Invalid Character', 'The character data is incomplete or invalid.');
                return;
            }
            
            // Show confirmation dialog for single character
            const characterName = characterToImport.name;
            const exportDate = data.exportDate ? new Date(data.exportDate).toLocaleDateString() : 'Unknown';
            
            showLoadSingleCharacterConfirmDialog(
                characterName,
                exportDate,
                () => {
                    // User confirmed - proceed with import
                    importSingleCharacter(characterToImport);
                }
            );
        }

        function handleMultipleCharactersLoad(data, fileName) {
            // Validate the data structure
            if (!data.characters || !Array.isArray(data.characters)) {
                showCustomDialog('Invalid File Format', 'The selected file does not contain valid character data.');
                return;
            }

            // Show confirmation dialog with details for multiple characters
            const importCount = data.characters.length;
            const exportDate = data.exportDate ? new Date(data.exportDate).toLocaleDateString() : 'Unknown';
            const currentCount = characters.length;
            
            showLoadConfirmDialog(
                importCount, 
                exportDate, 
                currentCount, 
                () => {
                    // User confirmed - proceed with import
                    importCharacters(data.characters);
                }
            );
        }

        // Save and Load Functions
        function saveAllCharacters() {
            if (characters.length === 0) {
                showCustomDialog('No Characters', 'There are no characters to save.');
                return;
            }

            try {
                const dataToSave = {
                    version: "1.0",
                    exportDate: new Date().toISOString(),
                    characterCount: characters.length,
                    characters: characters
                };

                const dataStr = JSON.stringify(dataToSave, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                // Create download link
                const url = URL.createObjectURL(dataBlob);
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = `rpg-characters-${new Date().toISOString().split('T')[0]}.json`;
                
                // Trigger download
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                
                // Clean up the URL object
                URL.revokeObjectURL(url);
                
                showCustomDialog('Export Successful', `Successfully exported ${characters.length} character(s) to your downloads folder.`);
            } catch (error) {
                console.error('Error saving characters:', error);
                showCustomDialog('Export Failed', 'Failed to export characters. Please try again.');
            }
        }

        function triggerLoadCharacters() {
            // Trigger the hidden file input
            document.getElementById('loadFileInput').click();
        }

        function loadCharactersFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Validate file type
            if (!file.name.endsWith('.json')) {
                showCustomDialog('Invalid File', 'Please select a valid JSON file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate the data structure
                    if (!data.characters || !Array.isArray(data.characters)) {
                        showCustomDialog('Invalid File Format', 'The selected file does not contain valid character data.');
                        return;
                    }

                    // Show confirmation dialog with details
                    const importCount = data.characters.length;
                    const exportDate = data.exportDate ? new Date(data.exportDate).toLocaleDateString() : 'Unknown';
                    const currentCount = characters.length;
                    
                    showLoadConfirmDialog(
                        importCount, 
                        exportDate, 
                        currentCount, 
                        () => {
                            // User confirmed - proceed with import
                            importCharacters(data.characters);
                        }
                    );

                } catch (error) {
                    console.error('Error parsing file:', error);
                    showCustomDialog('File Error', 'Failed to read the file. Please ensure it is a valid RPG Character Manager export.');
                }
            };

            reader.readAsText(file);
            
            // Reset the file input so the same file can be selected again
            event.target.value = '';
        }

        function showLoadConfirmDialog(importCount, exportDate, currentCount, onConfirm) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4 text-blue-600 dark:text-blue-400">
                        <i class="fas fa-upload mr-2"></i>Import Characters
                    </h3>
                    <div class="space-y-3 mb-6">
                        <p class="text-gray-700 dark:text-gray-300">
                            <strong>File contains:</strong> ${importCount} character(s)
                        </p>
                        <p class="text-gray-700 dark:text-gray-300">
                            <strong>Export date:</strong> ${exportDate}
                        </p>
                        <p class="text-gray-700 dark:text-gray-300">
                            <strong>Current characters:</strong> ${currentCount}
                        </p>
                        <div class="p-3 bg-yellow-50 dark:bg-yellow-900 rounded-lg">
                            <p class="text-yellow-800 dark:text-yellow-200 text-sm">
                                <i class="fas fa-exclamation-triangle mr-1"></i>
                                ${currentCount > 0 ? 
                                    'This will replace all current characters. Your existing characters will be lost.' : 
                                    'This will import the characters from the file.'
                                }
                            </p>
                        </div>
                    </div>
                    <div class="flex justify-end space-x-3">
                        <button class="cancel-import px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                        <button class="confirm-import px-4 py-2 bg-blue-500 text-white hover:bg-blue-600 rounded">Import Characters</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.querySelector('.confirm-import').addEventListener('click', () => {
                onConfirm();
                modal.remove();
            });
            
            modal.querySelector('.cancel-import').addEventListener('click', () => {
                modal.remove();
            });
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.remove();
                }
            });
        }

        function importCharacters(importedCharacters) {
            try {
                // Validate each character has required properties
                const validCharacters = importedCharacters.filter(char => {
                    return char.id && char.name && char.race && char.class;
                });

                if (validCharacters.length === 0) {
                    showCustomDialog('Import Failed', 'No valid characters found in the file.');
                    return;
                }

                // Replace current characters with imported ones
                characters = validCharacters.map(char => ({
                    // Ensure all required properties exist with defaults
                    id: char.id || Date.now().toString(),
                    name: char.name || 'Unknown Character',
                    level: char.level || 1,
                    race: char.race || 'Human',
                    class: char.class || 'Fighter',
                    str: char.str || 0,
                    dex: char.dex || 0,
                    con: char.con || 0,
                    int: char.int || 0,
                    wis: char.wis || 0,
                    cha: char.cha || 0,
                    proficiencies: char.proficiencies || { str: false, dex: false, con: false, int: false, wis: false, cha: false },
                    abilityScoreAllocations: char.abilityScoreAllocations || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 },
                    hpMax: char.hpMax || 0,
                    stressMax: char.stressMax || 0,
                    classMax: char.classMax || 0,
                    spellMax: char.spellMax || 0,
                    resources: char.resources || {
                        hp: { max: char.hpMax || 0, used: [], temp: 0 },
                        stress: { max: char.stressMax || 0, used: [], temp: 0 },
                        class: { max: char.classMax || 0, used: [], temp: 0 },
                        spell: { max: char.spellMax || 0, used: [], temp: 0 }
                    },
                    evasion: char.evasion || 0,
                    armor: char.armor || 1,
                    armorSlots: char.armorSlots || { total: char.armor || 1, filled: [], permanent: char.armor || 1, temporary: 0 },
                    thresholdLower: char.thresholdLower || 0,
                    thresholdUpper: char.thresholdUpper || 0,
                    equipment: char.equipment || [],
                    notes: char.notes || '',
                    // Preserve all other character properties
                    ...char
                }));

                // Clear current character if it no longer exists
                if (currentCharacter && !characters.find(c => c.id === currentCharacter.id)) {
                    currentCharacter = null;
                }

                // Save and update display
                saveCharacters();
                updateCharacterDisplay();
                
                // Show success message
                const importedCount = validCharacters.length;
                const skippedCount = importedCharacters.length - validCharacters.length;
                
                let message = `Successfully imported ${importedCount} character(s).`;
                if (skippedCount > 0) {
                    message += ` ${skippedCount} character(s) were skipped due to invalid data.`;
                }
                
                showCustomDialog('Import Successful', message);
                
                // Return to character list
                showCharacterList();

            } catch (error) {
                console.error('Error importing characters:', error);
                showCustomDialog('Import Failed', 'Failed to import characters. Please try again with a valid file.');
            }
        }

        // Character Deletion Functions
        function showCharacterDeletionModal() {
            if (!currentCharacter) return;
            
            const modal = document.getElementById('characterDeletionModal');
            const characterNameElement = document.getElementById('deleteCharacterName');
            const checkbox = document.getElementById('deleteConfirmationCheckbox');
            const confirmButton = document.getElementById('confirmCharacterDeletion');
            
            // Set character name in the modal
            characterNameElement.textContent = currentCharacter.name;
            
            // Reset checkbox and button state
            checkbox.checked = false;
            confirmButton.disabled = true;
            confirmButton.classList.add('opacity-50', 'cursor-not-allowed');
            
            modal.classList.remove('hidden');
        }

        function deleteCurrentCharacter() {
            if (!currentCharacter) return;
            
            // Find and remove the character from the characters array
            const characterIndex = characters.findIndex(char => char.id === currentCharacter.id);
            if (characterIndex !== -1) {
                characters.splice(characterIndex, 1);
                saveCharacters();
                
                // Hide the modal
                document.getElementById('characterDeletionModal').classList.add('hidden');
                
                // Go back to character list
                showCharacterList();
                updateCharacterDisplay();
                
                // Clear current character reference
                currentCharacter = null;
                
                showCustomDialog('Character Deleted', 'The character has been successfully deleted.');
            }
        }

        function showCharacterEdit() {
            document.querySelectorAll('.character-view').forEach(view => view.classList.remove('active'));
            document.getElementById('characterEdit').classList.add('active');
            populateCharacterEditForm();
        }

        function populateCharacterEditForm() {
            if (!currentCharacter) return;
            
            // Populate basic information
            document.getElementById('editCharName').value = currentCharacter.name || '';
            document.getElementById('editCharLevel').value = currentCharacter.level || 1;
            document.getElementById('editCharRace').value = currentCharacter.race || '--';
            document.getElementById('editCharClass').value = currentCharacter.class || '--';
            
            // Populate ability scores with manual input fields
            const raceAbilityBonuses = currentCharacter.abilityScoreAllocations || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const primaryWeaponAbilityBonuses = currentCharacter.primaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const secondaryWeaponAbilityBonuses = currentCharacter.secondaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const armorAbilityBonuses = currentCharacter.armorAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            
            // Set the direct input fields with the current total values
            document.getElementById('editStrInput').value = (currentCharacter.str || 0) + raceAbilityBonuses.str + primaryWeaponAbilityBonuses.str + secondaryWeaponAbilityBonuses.str + armorAbilityBonuses.str;
            document.getElementById('editDexInput').value = (currentCharacter.dex || 0) + raceAbilityBonuses.dex + primaryWeaponAbilityBonuses.dex + secondaryWeaponAbilityBonuses.dex + armorAbilityBonuses.dex;
            document.getElementById('editConInput').value = (currentCharacter.con || 0) + raceAbilityBonuses.con + primaryWeaponAbilityBonuses.con + secondaryWeaponAbilityBonuses.con + armorAbilityBonuses.con;
            document.getElementById('editIntInput').value = (currentCharacter.int || 0) + raceAbilityBonuses.int + primaryWeaponAbilityBonuses.int + secondaryWeaponAbilityBonuses.int + armorAbilityBonuses.int;
            document.getElementById('editWisInput').value = (currentCharacter.wis || 0) + raceAbilityBonuses.wis + primaryWeaponAbilityBonuses.wis + secondaryWeaponAbilityBonuses.wis + armorAbilityBonuses.wis;
            document.getElementById('editChaInput').value = (currentCharacter.cha || 0) + raceAbilityBonuses.cha + primaryWeaponAbilityBonuses.cha + secondaryWeaponAbilityBonuses.cha + armorAbilityBonuses.cha;
            
            // Populate resources with the actual current maximum values
            document.getElementById('editHpMax').value = currentCharacter.resources?.hp?.max || currentCharacter.hpMax || 0;
            document.getElementById('editStressMax').value = currentCharacter.resources?.stress?.max || currentCharacter.stressMax || 0;
            document.getElementById('editClassMax').value = currentCharacter.resources?.class?.max || currentCharacter.classMax || 0;
            document.getElementById('editSpellMax').value = currentCharacter.resources?.spell?.max || currentCharacter.spellMax || 0;
            
            // Populate combat stats
            document.getElementById('editEvasion').value = currentCharacter.evasion || 0;
            document.getElementById('editArmor').value = currentCharacter.armor || 0;
            
            // Populate threshold values - show the actual stored base values
            document.getElementById('editThresholdLower').value = currentCharacter.thresholdLower || 0;
            document.getElementById('editThresholdUpper').value = currentCharacter.thresholdUpper || 0;
            
            // Handle familiar section
            const editFamiliarSection = document.getElementById('editFamiliarSection');
            if (currentCharacter.class === 'Wizard' || currentCharacter.class === 'Warlock') {
                editFamiliarSection.style.display = 'block';
                
                // Set familiar checkbox and name
                const hasFamiliarCheckbox = document.getElementById('editHasFamiliar');
                const familiarNameSection = document.getElementById('editFamiliarNameSection');
                const familiarNameInput = document.getElementById('editFamiliarName');
                
                if (currentCharacter.familiar) {
                    hasFamiliarCheckbox.checked = true;
                    familiarNameSection.classList.remove('hidden');
                    familiarNameInput.value = currentCharacter.familiar.name || 'Familiar';
                } else {
                    hasFamiliarCheckbox.checked = false;
                    familiarNameSection.classList.add('hidden');
                    familiarNameInput.value = '';
                }
            } else {
                editFamiliarSection.style.display = 'none';
            }
            
            // Generate resource boxes
            setTimeout(() => {
                generateResourceBoxes('editHpBoxes', currentCharacter.resources?.hp?.max || currentCharacter.hpMax || 0, 'hp');
                generateResourceBoxes('editStressBoxes', currentCharacter.resources?.stress?.max || currentCharacter.stressMax || 0, 'stress');
                generateResourceBoxes('editClassBoxes', currentCharacter.resources?.class?.max || currentCharacter.classMax || 0, 'class');
                generateResourceBoxes('editSpellBoxes', currentCharacter.resources?.spell?.max || currentCharacter.spellMax || 0, 'spell');
            }, 100);
        }

        // Function to populate Character Creation form with existing character data
        function populateCharacterCreationForm() {
            if (!currentCharacter) return;
            
            // Switch to character edit view instead
            showCharacterEdit();
            
            // Wait for the form to be visible before populating
            setTimeout(() => {
                // Basic Information
                document.getElementById('charName').value = currentCharacter.name || '';
                document.getElementById('charLevel').value = currentCharacter.level || 1;
                document.getElementById('charRace').value = currentCharacter.race || '--';
                document.getElementById('charClass').value = currentCharacter.class || '--';
                
                // Handle race selection first to set up race bonuses/proficiencies
                if (currentCharacter.race && currentCharacter.race !== '--') {
                    updateRaceOptions(currentCharacter.race);
                    
                    // Restore race bonus selections
                    if (currentCharacter.selectedRaceBonuses) {
                        currentCharacter.selectedRaceBonuses.forEach(bonusIndex => {
                            const button = document.querySelector(`[data-index="${bonusIndex}"][data-category="bonus"]`);
                            if (button) {
                                button.classList.add('selected');
                                selectedRaceBonuses.push(bonusIndex);
                            }
                        });
                    }
                    
                    // Restore ability score selections if they exist
                    if (currentCharacter.abilityScoreAllocations) {
                        abilityScoreAllocations = { ...currentCharacter.abilityScoreAllocations };
                        
                        // Check if there are any non-zero allocations
                        const hasAllocations = Object.values(abilityScoreAllocations).some(value => value !== 0);
                        if (hasAllocations) {
                            selectedAbilityScores = currentCharacter.selectedAbilityScores || [];
                            const abilityButton = document.querySelector('[data-category="ability"]');
                            if (abilityButton) {
                                abilityButton.classList.add('selected');
                            }
                        }
                    }
                    
                    // Restore race proficiency selections
                    if (currentCharacter.selectedRaceProficiencies) {
                        currentCharacter.selectedRaceProficiencies.forEach(proficiency => {
                            const button = document.querySelector(`[data-ability="${proficiency}"].race-proficiency-button`);
                            if (button) {
                                button.classList.add('selected');
                                selectedRaceProficiencies.push(proficiency);
                            }
                        });
                    }
                    
                    // Restore race bonus values
                    if (currentCharacter.raceBonusValues) {
                        raceBonusValues = { ...currentCharacter.raceBonusValues };
                    }
                }
                
                // Handle class selection to update base values
                if (currentCharacter.class && currentCharacter.class !== '--') {
                    updateClassValues(currentCharacter.class);
                }
                
                // Ability Scores - restore modifiers and proficiencies
                if (currentCharacter.str !== undefined) selectedModifiers.str = currentCharacter.str;
                if (currentCharacter.dex !== undefined) selectedModifiers.dex = currentCharacter.dex;
                if (currentCharacter.con !== undefined) selectedModifiers.con = currentCharacter.con;
                if (currentCharacter.int !== undefined) selectedModifiers.int = currentCharacter.int;
                if (currentCharacter.wis !== undefined) selectedModifiers.wis = currentCharacter.wis;
                if (currentCharacter.cha !== undefined) selectedModifiers.cha = currentCharacter.cha;
                
                // Update used modifiers array
                usedModifiers = [];
                Object.values(selectedModifiers).forEach((modifier, index) => {
                    if (modifier !== null) {
                        const modifierIndex = availableModifiers.findIndex((mod, i) => 
                            mod === modifier && !usedModifiers.includes(i)
                        );
                        if (modifierIndex !== -1) {
                            usedModifiers.push(modifierIndex);
                        }
                    }
                });
                
                // Restore proficiencies
                if (currentCharacter.proficiencies) {
                    proficiencies = { ...currentCharacter.proficiencies };
                }
                
                // Resources - use base values only (not including race bonuses)
                const classInfo = classData[currentCharacter.class] || { hp: 0, stress: 0, class: 0, spell: 0 };
                document.getElementById('hpMax').value = classInfo.hp + (raceBonusValues.hp || 0);
                document.getElementById('stressMax').value = classInfo.stress + (raceBonusValues.stress || 0);
                document.getElementById('classMax').value = classInfo.class + (raceBonusValues.class || 0);
                document.getElementById('spellMax').value = classInfo.spell + (raceBonusValues.spell || 0);
                
                // Evasion - use base evasion (without temporary and armor values)
                let baseEvasion = currentCharacter.evasion || 0;
                
                // If we have evasion data, use the base value
                if (currentCharacter.evasionData && currentCharacter.evasionData.base !== undefined) {
                    baseEvasion = currentCharacter.evasionData.base;
                } else {
                    // Calculate base by removing temporary and armor bonuses
                    const tempEvasion = currentCharacter.evasionData?.temporary || 0;
                    const armorEvasion = getArmorEvasionValue(currentCharacter);
                    baseEvasion = (currentCharacter.evasion || 0) - tempEvasion - armorEvasion;
                }
                
                document.getElementById('evasion').value = baseEvasion;
                
                // Armor - use base armor value
                let baseArmor = 0;
                if (currentCharacter.armorSlots && currentCharacter.armorSlots.permanent !== undefined) {
                    baseArmor = currentCharacter.armorSlots.permanent;
                } else {
                    baseArmor = currentCharacter.armor || 0;
                }
                document.getElementById('armor').value = baseArmor;
                
                // Threshold - use base threshold values (not temporary)
                let baseLowerThreshold = currentCharacter.thresholdLower || 0;
                let baseUpperThreshold = currentCharacter.thresholdUpper || 0;
                
                // Remove temporary threshold bonuses if they exist
                if (currentCharacter.tempThreshold) {
                    baseLowerThreshold -= currentCharacter.tempThreshold.lower || 0;
                    baseUpperThreshold -= currentCharacter.tempThreshold.upper || 0;
                }
                
                document.getElementById('thresholdLower').value = baseLowerThreshold;
                document.getElementById('thresholdUpper').value = baseUpperThreshold;
                
                // Update all displays
                updateAvailableModifiers();
                updateAbilitySelectors();
                updateProficiencyCircles();
                updateAbilityScoreResults();
                
                // Regenerate resource boxes with current values
                setTimeout(() => {
                    generateResourceBoxes('hpBoxes', parseInt(document.getElementById('hpMax').value) || 0, 'hp');
                    generateResourceBoxes('stressBoxes', parseInt(document.getElementById('stressMax').value) || 0, 'stress');
                    generateResourceBoxes('classBoxes', parseInt(document.getElementById('classMax').value) || 0, 'class');
                    generateResourceBoxes('spellBoxes', parseInt(document.getElementById('spellMax').value) || 0, 'spell');
                }, 100);
                
            }, 100);
        }

        // Individual Character Save/Load Functions
        function saveIndividualCharacter() {
            if (!currentCharacter) return;
            
            try {
                const dataToSave = {
                    version: "1.0",
                    exportDate: new Date().toISOString(),
                    character: currentCharacter
                };
                
                const dataStr = JSON.stringify(dataToSave, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                // Create download link
                const url = URL.createObjectURL(dataBlob);
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                
                // Clean character name for filename
                const cleanName = currentCharacter.name.replace(/[^a-z0-9]/gi, '-').toLowerCase();
                downloadLink.download = `${cleanName}-character.json`;
                
                // Trigger download
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                
                // Clean up the URL object
                URL.revokeObjectURL(url);
                
                showCustomDialog('Character Saved', `Successfully saved ${currentCharacter.name} to your downloads folder.`);
            } catch (error) {
                console.error('Error saving character:', error);
                showCustomDialog('Save Failed', 'Failed to save character. Please try again.');
            }
        }
        
        function loadIndividualCharacter() {
            // Trigger the hidden file input for single character
            document.getElementById('loadSingleCharacterInput').click();
        }
        
        function loadSingleCharacterFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Validate file type
            if (!file.name.endsWith('.json')) {
                showCustomDialog('Invalid File', 'Please select a valid JSON file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Check if it's a single character file or characters file
                    let characterToImport = null;
                    
                    if (data.character) {
                        // Single character format
                        characterToImport = data.character;
                    } else if (data.characters && Array.isArray(data.characters) && data.characters.length === 1) {
                        // Single character in characters array format
                        characterToImport = data.characters[0];
                    } else if (data.characters && Array.isArray(data.characters) && data.characters.length > 1) {
                        showCustomDialog('Multiple Characters', 'This file contains multiple characters. Please use "Load All" to import multiple characters.');
                        return;
                    } else {
                        showCustomDialog('Invalid File Format', 'The selected file does not contain valid character data.');
                        return;
                    }
                    
                    // Validate character has required properties
                    if (!characterToImport.name || !characterToImport.race || !characterToImport.class) {
                        showCustomDialog('Invalid Character', 'The character data is incomplete or invalid.');
                        return;
                    }
                    
                    // Show confirmation dialog
                    const characterName = characterToImport.name;
                    const exportDate = data.exportDate ? new Date(data.exportDate).toLocaleDateString() : 'Unknown';
                    
                    showLoadSingleCharacterConfirmDialog(
                        characterName,
                        exportDate,
                        () => {
                            // User confirmed - proceed with import
                            importSingleCharacter(characterToImport);
                        }
                    );
                    
                } catch (error) {
                    console.error('Error parsing character file:', error);
                    showCustomDialog('File Error', 'Failed to read the file. Please ensure it is a valid character file.');
                }
            };
            
            reader.readAsText(file);
            
            // Reset the file input so the same file can be selected again
            event.target.value = '';
        }
        
        function showLoadSingleCharacterConfirmDialog(characterName, exportDate, onConfirm) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4 text-green-600 dark:text-green-400">
                        <i class="fas fa-user-plus mr-2"></i>Load Character
                    </h3>
                    <div class="space-y-3 mb-6">
                        <p class="text-gray-700 dark:text-gray-300">
                            <strong>Character:</strong> ${characterName}
                        </p>
                        <p class="text-gray-700 dark:text-gray-300">
                            <strong>Export date:</strong> ${exportDate}
                        </p>
                        <div class="p-3 bg-green-50 dark:bg-green-900 rounded-lg">
                            <p class="text-green-800 dark:text-green-200 text-sm">
                                <i class="fas fa-info-circle mr-1"></i>
                                This character will be added to your character list.
                            </p>
                        </div>
                    </div>
                    <div class="flex justify-end space-x-3">
                        <button class="cancel-load px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                        <button class="confirm-load px-4 py-2 bg-green-500 text-white hover:bg-green-600 rounded">Load Character</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.querySelector('.confirm-load').addEventListener('click', () => {
                onConfirm();
                modal.remove();
            });
            
            modal.querySelector('.cancel-load').addEventListener('click', () => {
                modal.remove();
            });
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.remove();
                }
            });
        }
        
        // Helper function to create a character from data with proper validation
        function createCharacterFromData(characterData, preserveId = null) {
            return {
                // Use preserved ID if provided, otherwise generate new one
                id: preserveId || Date.now().toString() + Math.random().toString(36).substr(2, 9),
                name: characterData.name || 'Unknown Character',
                level: characterData.level || 1,
                race: characterData.race || 'Human',
                class: characterData.class || 'Fighter',
                str: characterData.str || 0,
                dex: characterData.dex || 0,
                con: characterData.con || 0,
                int: characterData.int || 0,
                wis: characterData.wis || 0,
                cha: characterData.cha || 0,
                proficiencies: characterData.proficiencies || { str: false, dex: false, con: false, int: false, wis: false, cha: false },
                abilityScoreAllocations: characterData.abilityScoreAllocations || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 },
                hpMax: characterData.hpMax || 0,
                stressMax: characterData.stressMax || 0,
                classMax: characterData.classMax || 0,
                spellMax: characterData.spellMax || 0,
                resources: characterData.resources || {
                    hp: { max: characterData.hpMax || 0, used: [], temp: 0 },
                    stress: { max: characterData.stressMax || 0, used: [], temp: 0 },
                    class: { max: characterData.classMax || 0, used: [], temp: 0 },
                    spell: { max: characterData.spellMax || 0, used: [], temp: 0 }
                },
                evasion: characterData.evasion || 0,
                armor: characterData.armor || 1,
                armorSlots: characterData.armorSlots || { total: characterData.armor || 1, filled: [], permanent: characterData.armor || 1, temporary: 0 },
                thresholdLower: characterData.thresholdLower || 0,
                thresholdUpper: characterData.thresholdUpper || 0,
                equipment: characterData.equipment || [],
                notes: characterData.notes || '',
                // Preserve all other character properties
                ...characterData,
                // Override ID only if preserveId is provided
                id: preserveId || Date.now().toString() + Math.random().toString(36).substr(2, 9)
            };
        }

        function showDuplicateCharacterDialog(characterData, callback) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
                    <h3 class="text-lg font-semibold mb-4 text-orange-600 dark:text-orange-400">
                        <i class="fas fa-exclamation-triangle mr-2"></i>Duplicate Character Name
                    </h3>
                    <p class="text-gray-700 dark:text-gray-300 mb-4">
                        A character named <strong>"${characterData.name}"</strong> already exists.
                    </p>
                    <p class="text-gray-700 dark:text-gray-300 mb-6">
                        Would you like to:
                    </p>
                    
                    <div class="space-y-3 mb-6">
                        <label class="flex items-center cursor-pointer">
                            <input type="radio" name="duplicateAction" value="overwrite" class="mr-3">
                            <div>
                                <div class="font-medium">Overwrite existing character</div>
                                <div class="text-sm text-gray-500 dark:text-gray-400">Replace the current character data with the new data</div>
                            </div>
                        </label>
                        
                        <label class="flex items-center cursor-pointer">
                            <input type="radio" name="duplicateAction" value="copy" class="mr-3">
                            <div>
                                <div class="font-medium">Create a copy</div>
                                <div class="text-sm text-gray-500 dark:text-gray-400">Add as "${characterData.name} - copy"</div>
                            </div>
                        </label>
                    </div>
                    
                    <div class="flex justify-end space-x-3">
                        <button class="cancel-duplicate px-4 py-2 text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 rounded">Cancel</button>
                        <button class="confirm-duplicate px-4 py-2 bg-orange-500 text-white hover:bg-orange-600 rounded">Continue</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            modal.querySelector('.confirm-duplicate').addEventListener('click', () => {
                const selectedAction = modal.querySelector('input[name="duplicateAction"]:checked');
                if (!selectedAction) {
                    showCustomDialog('No Option Selected', 'Please select an option to continue.');
                    return;
                }
                
                let finalCharacterData = { ...characterData };
                
                if (selectedAction.value === 'copy') {
                    // Add " - copy" to the name for the copy option
                    finalCharacterData.name = `${characterData.name} - copy`;
                }
                
                callback(selectedAction.value, finalCharacterData);
                modal.remove();
            });
            
            modal.querySelector('.cancel-duplicate').addEventListener('click', () => {
                modal.remove();
            });
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === this) {
                    this.remove();
                }
            });
        }

        function importSingleCharacter(characterData) {
            try {
                // Check for duplicate names
                const existingCharacter = characters.find(char => char.name === characterData.name);
                
                if (existingCharacter) {
                    // Show duplicate warning dialog
                    showDuplicateCharacterDialog(characterData, (action, finalCharacterData) => {
                        if (action === 'overwrite') {
                            // Update existing character with new data while preserving ID
                            const updatedCharacter = createCharacterFromData(finalCharacterData, existingCharacter.id);
                            const existingIndex = characters.findIndex(char => char.id === existingCharacter.id);
                            characters[existingIndex] = updatedCharacter;
                            
                            saveCharacters();
                            updateCharacterDisplay();
                            showCustomDialog('Character Updated', `Successfully updated ${updatedCharacter.name} with new data.`);
                        } else if (action === 'copy') {
                            // Create new character with copy name
                            const newCharacter = createCharacterFromData(finalCharacterData);
                            characters.push(newCharacter);
                            
                            saveCharacters();
                            updateCharacterDisplay();
                            showCustomDialog('Character Copy Created', `Successfully created ${newCharacter.name}.`);
                        }
                        
                        showCharacterList();
                    });
                    return;
                }
                
                // No duplicate found, proceed normally
                const newCharacter = createCharacterFromData(characterData);
                characters.push(newCharacter);
                
                saveCharacters();
                updateCharacterDisplay();
                showCustomDialog('Character Loaded', `Successfully loaded ${newCharacter.name} and added to your character list.`);
                showCharacterList();
                
            } catch (error) {
                console.error('Error importing character:', error);
                showCustomDialog('Import Failed', 'Failed to import character. Please try again with a valid file.');
            }
        }

        // Close modals when clicking outside
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('fixed') && e.target.classList.contains('inset-0')) {
                e.target.classList.add('hidden');
            }
        });

       // Create 6 weapon proficiency circles
        function createWeaponCircles() {
            const container = document.getElementById('weapon-circles-container');
            
            for (let i = 0; i < 6; i++) {
                const circle = document.createElement('button');
                circle.type = 'button';
                circle.className = 'weapon-proficiency-circle w-6 h-6 rounded-full border-2 border-dashed border-gray-400 dark:border-gray-500 bg-transparent hover:border-gray-600 dark:hover:border-gray-300';
                circle.setAttribute('data-index', i);
                
                // First circle is always filled and unclickable
                if (i === 0) {
                    circle.className = 'weapon-proficiency-circle w-6 h-6 rounded-full border-2 bg-black proficient';
                    circle.setAttribute('data-filled', 'true');
                    circle.style.cursor = 'default';
                    circle.disabled = true;
                } else {
                    circle.setAttribute('data-filled', 'false');
                    
                    // Add click event listener for sequential filling/unfilling
                    circle.addEventListener('click', function() {
                        handleCircleClick(parseInt(this.getAttribute('data-index')));
                    });
                }
                
                container.appendChild(circle);
            }
        }

        // Handle manual circle clicks that update character data
        function handleCircleClick(clickedIndex) {
            if (!currentCharacter) return;
            
            const currentProficiency = currentCharacter.weaponProficiency || 1;
            
            // Check if this is the next circle to fill (left to right)
            if (clickedIndex === currentProficiency) {
                // Fill this circle and update character data
                currentCharacter.weaponProficiency = clickedIndex + 1;
                updateWeaponProficiencyDisplay(currentCharacter.weaponProficiency);
                saveCharacters();
            }
            // Check if this is the rightmost filled circle to unfill (right to left)
            else if (clickedIndex === currentProficiency - 1 && clickedIndex > 0) {
                // Unfill this circle and update character data
                currentCharacter.weaponProficiency = clickedIndex;
                updateWeaponProficiencyDisplay(currentCharacter.weaponProficiency);
                saveCharacters();
            }
        }

        // Weapon proficiency level up function
        function applyWeaponProficiencyLevelUp() {
            if (!currentCharacter) return;
            
            // Initialize weapon proficiency if not present
            if (!currentCharacter.weaponProficiency) {
                currentCharacter.weaponProficiency = 1; // Start with 1 circle filled at level 1
            }
            
            // Check if we can fill another circle (max 6)
            if (currentCharacter.weaponProficiency < 6) {
                currentCharacter.weaponProficiency++;
            }
            
            // Update the weapon proficiency circles display
            updateWeaponProficiencyDisplay(currentCharacter.weaponProficiency);
        }

        // Update weapon proficiency display based on character data
        function updateWeaponProficiencyDisplay(proficiencyLevel) {
            const circles = document.querySelectorAll('.weapon-proficiency-circle');
            
            circles.forEach((circle, index) => {
                if (index < proficiencyLevel) {
                    circle.classList.add('proficient');
                    circle.setAttribute('data-filled', 'true');
                } else {
                    circle.classList.remove('proficient');
                    circle.setAttribute('data-filled', 'false');
                }
            });
        }

        // Count how many circles are currently filled
        function getFilledCircleCount() {
            return currentCharacter?.weaponProficiency || 1;
        }

        // Initialize circles when page loads
        document.addEventListener('DOMContentLoaded', createWeaponCircles);

        // Edit Character Form Event Handlers
        document.getElementById('editCharacterForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            if (!currentCharacter) return;
            
            // Update basic information
            currentCharacter.name = document.getElementById('editCharName').value;
            currentCharacter.level = parseInt(document.getElementById('editCharLevel').value);
            currentCharacter.race = document.getElementById('editCharRace').value;
            currentCharacter.class = document.getElementById('editCharClass').value;
            
            // Update ability scores from direct input fields - remove all existing bonuses and apply new totals
            const strInput = parseInt(document.getElementById('editStrInput').value) || 0;
            const dexInput = parseInt(document.getElementById('editDexInput').value) || 0;
            const conInput = parseInt(document.getElementById('editConInput').value) || 0;
            const intInput = parseInt(document.getElementById('editIntInput').value) || 0;
            const wisInput = parseInt(document.getElementById('editWisInput').value) || 0;
            const chaInput = parseInt(document.getElementById('editChaInput').value) || 0;
            
            // Calculate the base ability scores by removing all bonuses
            const raceAbilityBonuses = currentCharacter.abilityScoreAllocations || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const primaryWeaponAbilityBonuses = currentCharacter.primaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const secondaryWeaponAbilityBonuses = currentCharacter.secondaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const armorAbilityBonuses = currentCharacter.armorAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            
            // Set base ability scores (input minus all bonuses)
            currentCharacter.str = strInput - raceAbilityBonuses.str - primaryWeaponAbilityBonuses.str - secondaryWeaponAbilityBonuses.str - armorAbilityBonuses.str;
            currentCharacter.dex = dexInput - raceAbilityBonuses.dex - primaryWeaponAbilityBonuses.dex - secondaryWeaponAbilityBonuses.dex - armorAbilityBonuses.dex;
            currentCharacter.con = conInput - raceAbilityBonuses.con - primaryWeaponAbilityBonuses.con - secondaryWeaponAbilityBonuses.con - armorAbilityBonuses.con;
            currentCharacter.int = intInput - raceAbilityBonuses.int - primaryWeaponAbilityBonuses.int - secondaryWeaponAbilityBonuses.int - armorAbilityBonuses.int;
            currentCharacter.wis = wisInput - raceAbilityBonuses.wis - primaryWeaponAbilityBonuses.wis - secondaryWeaponAbilityBonuses.wis - armorAbilityBonuses.wis;
            currentCharacter.cha = chaInput - raceAbilityBonuses.cha - primaryWeaponAbilityBonuses.cha - secondaryWeaponAbilityBonuses.cha - armorAbilityBonuses.cha;
            
            // Update resources
            currentCharacter.hpMax = parseInt(document.getElementById('editHpMax').value) || 0;
            currentCharacter.stressMax = parseInt(document.getElementById('editStressMax').value) || 0;
            currentCharacter.classMax = parseInt(document.getElementById('editClassMax').value) || 0;
            currentCharacter.spellMax = parseInt(document.getElementById('editSpellMax').value) || 0;
            
            // Update resources object
            if (!currentCharacter.resources) {
                currentCharacter.resources = {
                    hp: { max: 0, used: [], temp: 0 },
                    stress: { max: 0, used: [], temp: 0 },
                    class: { max: 0, used: [], temp: 0 },
                    spell: { max: 0, used: [], temp: 0 }
                };
            }
            
            currentCharacter.resources.hp.max = currentCharacter.hpMax;
            currentCharacter.resources.stress.max = currentCharacter.stressMax;
            currentCharacter.resources.class.max = currentCharacter.classMax;
            currentCharacter.resources.spell.max = currentCharacter.spellMax;
            
            // Clean up used resources that are now beyond the max
            Object.keys(currentCharacter.resources).forEach(resourceType => {
                const resource = currentCharacter.resources[resourceType];
                const totalMax = resource.max + (resource.temp || 0);
                resource.used = resource.used.filter(index => index < totalMax);
            });
            
            // Update combat stats
            currentCharacter.evasion = parseInt(document.getElementById('editEvasion').value) || 0;
            currentCharacter.armor = parseInt(document.getElementById('editArmor').value) || 0;
            
            // Update armor slots to match new armor value
            if (!currentCharacter.armorSlots) {
                currentCharacter.armorSlots = { 
                    total: currentCharacter.armor, 
                    filled: [],
                    permanent: currentCharacter.armor,
                    temporary: 0
                };
            } else {
                currentCharacter.armorSlots.permanent = currentCharacter.armor;
                currentCharacter.armorSlots.total = currentCharacter.armor + (currentCharacter.armorSlots.temporary || 0);
                // Remove filled states that are now beyond the total
                currentCharacter.armorSlots.filled = currentCharacter.armorSlots.filled.filter(index => index < currentCharacter.armorSlots.total);
            }
            
            // Update threshold values
            currentCharacter.thresholdLower = parseInt(document.getElementById('editThresholdLower').value) || 0;
            currentCharacter.thresholdUpper = parseInt(document.getElementById('editThresholdUpper').value) || 0;
            
            // Handle familiar data for Wizard and Warlock
            if (currentCharacter.class === 'Wizard' || currentCharacter.class === 'Warlock') {
                if (document.getElementById('editHasFamiliar').checked) {
                    const familiarName = document.getElementById('editFamiliarName').value.trim() || 'Familiar';
                    if (!currentCharacter.familiar) {
                        currentCharacter.familiar = {
                            name: familiarName,
                            hpUsed: false,
                            stressUsed: 0
                        };
                    } else {
                        currentCharacter.familiar.name = familiarName;
                    }
                } else {
                    // Remove familiar if unchecked
                    currentCharacter.familiar = null;
                }
            } else {
                // Remove familiar if class is changed away from Wizard/Warlock
                currentCharacter.familiar = null;
            }
            
            // Handle companion data for Ranger
            if (currentCharacter.class === 'Ranger') {
                if (document.getElementById('editHasCompanion').checked) {
                    const companionName = document.getElementById('editCompanionName').value.trim() || 'Companion';
                    const companionType = document.getElementById('editCompanionType').value || 'Bear';
                    if (!currentCharacter.companion) {
                        currentCharacter.companion = {
                            name: companionName,
                            type: companionType,
                            hpUsed: [], // Array of used HP box indices
                            stressUsed: [] // Array of used Stress box indices
                        };
                    } else {
                        currentCharacter.companion.name = companionName;
                        currentCharacter.companion.type = companionType;
                    }
                } else {
                    // Remove companion if unchecked
                    currentCharacter.companion = null;
                }
            } else {
                // Remove companion if class is changed away from Ranger
                currentCharacter.companion = null;
            }
            
            // Save changes
            saveCharacters();
            updateCharacterDisplay();
            showCharacterSheet(currentCharacter);
        });

        // Edit form resource input event listeners
        document.getElementById('editHpMax').addEventListener('input', function() {
            generateResourceBoxes('editHpBoxes', parseInt(this.value) || 0, 'hp');
        });
        
        document.getElementById('editStressMax').addEventListener('input', function() {
            generateResourceBoxes('editStressBoxes', parseInt(this.value) || 0, 'stress');
        });
        
        document.getElementById('editClassMax').addEventListener('input', function() {
            generateResourceBoxes('editClassBoxes', parseInt(this.value) || 0, 'class');
        });
        
        document.getElementById('editSpellMax').addEventListener('input', function() {
            generateResourceBoxes('editSpellBoxes', parseInt(this.value) || 0, 'spell');
        });

        // Unarmored Defense helper functions
        function getCurrentDexModifier(character) {
            const raceAbilityBonuses = character.abilityScoreAllocations || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const primaryWeaponAbilityBonuses = character.primaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const secondaryWeaponAbilityBonuses = character.secondaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const armorAbilityBonuses = character.armorAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            
            return (character.dex || 0) + raceAbilityBonuses.dex + primaryWeaponAbilityBonuses.dex + secondaryWeaponAbilityBonuses.dex + armorAbilityBonuses.dex;
        }
        
        function getCurrentConModifier(character) {
            const raceAbilityBonuses = character.abilityScoreAllocations || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const primaryWeaponAbilityBonuses = character.primaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const secondaryWeaponAbilityBonuses = character.secondaryWeaponAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            const armorAbilityBonuses = character.armorAbilityBonuses || { str: 0, dex: 0, con: 0, int: 0, wis: 0, cha: 0 };
            
            return (character.con || 0) + raceAbilityBonuses.con + primaryWeaponAbilityBonuses.con + secondaryWeaponAbilityBonuses.con + armorAbilityBonuses.con;
        }
        
        function getInitialDexModifier(character) {
            return character.initialModifiers?.dex || 0;
        }
        
        function handleUnarmoredDefenseToggle(isChecked) {
            if (!currentCharacter) return;
            
            if (isChecked) {
                // Apply Unarmored Defense bonuses
                applyUnarmoredDefenseBonuses();
                currentCharacter.unarmoredDefenseActive = true;
            } else {
                // Remove Unarmored Defense bonuses
                removeUnarmoredDefenseBonuses();
                currentCharacter.unarmoredDefenseActive = false;
            }
            
            saveCharacters();
            populateCharacterSheet(currentCharacter);
        }
        
        function applyUnarmoredDefenseBonuses() {
            if (!currentCharacter) return;
            
            // Initialize evasion data if missing
            if (!currentCharacter.evasionData) {
                currentCharacter.evasionData = {
                    base: currentCharacter.evasion || 0,
                    temporary: 0,
                    unarmoredDefense: 0,
                    mageArmor: 0
                };
            }
            
            // Add initial DEX modifier to evasion data
            const initialDexMod = getInitialDexModifier(currentCharacter);
            currentCharacter.evasionData.unarmoredDefense = initialDexMod;
            
            // Update character's main evasion value
            currentCharacter.evasion = getCurrentEvasion(currentCharacter);
            
            // Auto-equip ceremonial Unarmored Defense "armor" for display purposes  
            if (!currentCharacter.armorItem) {
                currentCharacter.armorItem = createUnarmoredDefenseArmor(currentCharacter.class);
            }
        }
        
        function removeUnarmoredDefenseBonuses() {
            if (!currentCharacter) return;
            
            // Initialize evasion data if missing
            if (!currentCharacter.evasionData) {
                currentCharacter.evasionData = {
                    base: currentCharacter.evasion || 0,
                    temporary: 0,
                    unarmoredDefense: 0,
                    mageArmor: 0
                };
            }
            
            // Remove Unarmored Defense evasion bonus
            currentCharacter.evasionData.unarmoredDefense = 0;
            
            // Update character's main evasion value
            currentCharacter.evasion = getCurrentEvasion(currentCharacter);
            
            // Remove Unarmored Defense "armor" if present
            if (currentCharacter.armorItem && currentCharacter.armorItem.isUnarmoredDefense) {
                delete currentCharacter.armorItem;
            }
        }
        
        function createUnarmoredDefenseArmor(characterClass) {
            if (characterClass === 'Barbarian') {
                return {
                    name: "Unarmored Defense (Barbarian)",
                    thresholdLower: 0,
                    thresholdUpper: 0,
                    armor: 0,
                    feature: "DEX to Evasion & Thresholds, CON to Upper Threshold",
                    bonuses: {}, // No actual bonuses - purely ceremonial
                    isUnarmoredDefense: true
                };
            } else if (characterClass === 'Monk') {
                return {
                    name: "Unarmored Defense (Monk)",
                    thresholdLower: 0,
                    thresholdUpper: 0,
                    armor: 0,
                    feature: "DEX to Evasion & Thresholds",
                    bonuses: {}, // No actual bonuses - purely ceremonial
                    isUnarmoredDefense: true
                };
            }
            return null;
        }
        
        function applyUnarmoredDefenseThresholdBonuses() {
            if (!currentCharacter || !currentCharacter.unarmoredDefenseActive) return;
            
            // Initialize if not present
            if (!currentCharacter.unarmoredDefenseThresholdBonuses) {
                currentCharacter.unarmoredDefenseThresholdBonuses = { lower: 0, upper: 0 };
            }
            
            // Add level-up bonus for Barbarians and Monks (+1/+1)
            if ((currentCharacter.class === 'Barbarian' || currentCharacter.class === 'Monk') && currentCharacter.level > 1) {
                currentCharacter.unarmoredDefenseThresholdBonuses.lower += (currentCharacter.level - 1);
                currentCharacter.unarmoredDefenseThresholdBonuses.upper += (currentCharacter.level - 1);
            }
        }
        
        function removeUnarmoredDefenseThresholdBonuses() {
            if (!currentCharacter) return;
            
            // Clear any Unarmored Defense threshold bonuses
            if (currentCharacter.unarmoredDefenseThresholdBonuses) {
                currentCharacter.unarmoredDefenseThresholdBonuses = { lower: 0, upper: 0 };
            }
        }
        
        function updateUnarmoredDefenseDisplay() {
            if (!currentCharacter) return;
            
            const section = document.getElementById('unarmoredDefenseSection');
            const checkbox = document.getElementById('unarmoredDefenseToggle');
            const description = document.getElementById('unarmoredDefenseDescription');
            
            // Show section only for Barbarian and Monk
            if (currentCharacter.class === 'Barbarian' || currentCharacter.class === 'Monk') {
                section.style.display = 'block';
                
                // Set description based on class
                if (currentCharacter.class === 'Monk') {
                    description.textContent = 'Add initial DEX modifier to Evasion and current DEX modifier to Thresholds';
                } else if (currentCharacter.class === 'Barbarian') {
                    description.textContent = 'Add initial DEX modifier to Evasion, current DEX to Lower Threshold, DEX+CON to Upper Threshold';
                }
                
                // Always keep checkbox enabled - just reflect current state
                checkbox.disabled = false;
                checkbox.checked = currentCharacter.unarmoredDefenseActive || false;
            } else {
                section.style.display = 'none';
            }
        }
        
        // Mage Armor Functions
        function handleMageArmorToggle(isChecked) {
            if (!currentCharacter) return;
            
            if (isChecked) {
                // Apply Mage Armor bonuses
                applyMageArmorBonuses();
                currentCharacter.mageArmorActive = true;
            } else {
                // Remove Mage Armor bonuses
                removeMageArmorBonuses();
                currentCharacter.mageArmorActive = false;
            }
            
            saveCharacters();
            populateCharacterSheet(currentCharacter);
        }
        
        function applyMageArmorBonuses() {
            if (!currentCharacter) return;
            
            const currentDex = getCurrentDexModifier(currentCharacter);
            const level = currentCharacter.level || 1;
            
            // Initialize Mage Armor bonuses if not present
            if (!currentCharacter.mageArmorBonuses) {
                currentCharacter.mageArmorBonuses = {
                    evasion: 0,
                    thresholdLower: 0,
                    thresholdUpper: 0
                };
            }
            
            // Calculate bonuses
            const evasionBonus = Math.max(1, currentDex);
            const lowerThresholdBonus = level;
            const upperThresholdBonus = level * 2;
            
            // Apply evasion bonus to current evasion
            currentCharacter.evasion = (currentCharacter.evasion || 0) + evasionBonus;
            
            // Apply temporary threshold bonuses
            if (!currentCharacter.tempThreshold) {
                currentCharacter.tempThreshold = { lower: 0, upper: 0 };
            }
            
            currentCharacter.tempThreshold.lower += lowerThresholdBonus;
            currentCharacter.tempThreshold.upper += upperThresholdBonus;
            
            // Store the applied bonuses for removal later
            currentCharacter.mageArmorBonuses = {
                evasion: evasionBonus,
                thresholdLower: lowerThresholdBonus,
                thresholdUpper: upperThresholdBonus
            };
        }
        
        function removeMageArmorBonuses() {
            if (!currentCharacter || !currentCharacter.mageArmorBonuses) return;
            
            const bonuses = currentCharacter.mageArmorBonuses;
            
            // Remove evasion bonus
            currentCharacter.evasion = (currentCharacter.evasion || 0) - bonuses.evasion;
            
            // Remove temporary threshold bonuses
            if (currentCharacter.tempThreshold) {
                currentCharacter.tempThreshold.lower -= bonuses.thresholdLower;
                currentCharacter.tempThreshold.upper -= bonuses.thresholdUpper;
                
                // Ensure temp thresholds don't go negative
                currentCharacter.tempThreshold.lower = Math.max(0, currentCharacter.tempThreshold.lower);
                currentCharacter.tempThreshold.upper = Math.max(0, currentCharacter.tempThreshold.upper);
            }
            
            // Clear the stored bonuses
            currentCharacter.mageArmorBonuses = {
                evasion: 0,
                thresholdLower: 0,
                thresholdUpper: 0
            };
        }
        
        function updateMageArmorDisplay() {
            if (!currentCharacter) return;
            
            const section = document.getElementById('mageArmorSection');
            const checkbox = document.getElementById('mageArmorToggle');
            
            // Show section only for Wizard and Sorcerer
            if (currentCharacter.class === 'Wizard' || currentCharacter.class === 'Sorcerer') {
                section.style.display = 'block';
                checkbox.checked = currentCharacter.mageArmorActive || false;
            } else {
                section.style.display = 'none';
            }
        }
    </script>
</body>
</html>
